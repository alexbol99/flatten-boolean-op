{"version":3,"sources":["webpack://flatten-boolean-op/webpack/universalModuleDefinition","webpack://flatten-boolean-op/webpack/bootstrap","webpack://flatten-boolean-op/./node_modules/flatten-interval-tree/index.js","webpack://flatten-boolean-op/./node_modules/flatten-interval-tree/utils/constants.js","webpack://flatten-boolean-op/./index.js","webpack://flatten-boolean-op/./node_modules/flatten-js/index.js","webpack://flatten-boolean-op/./node_modules/flatten-js/utils/utils.js","webpack://flatten-boolean-op/./node_modules/flatten-js/utils/errors.js","webpack://flatten-boolean-op/./node_modules/flatten-js/classes/matrix.js","webpack://flatten-boolean-op/./node_modules/flatten-js/data_structures/planar_set.js","webpack://flatten-boolean-op/./node_modules/flatten-interval-tree/classes/node.js","webpack://flatten-boolean-op/./node_modules/flatten-interval-tree/classes/interval.js","webpack://flatten-boolean-op/./node_modules/flatten-js/classes/point.js","webpack://flatten-boolean-op/./node_modules/flatten-js/classes/vector.js","webpack://flatten-boolean-op/./node_modules/flatten-js/classes/line.js","webpack://flatten-boolean-op/./node_modules/flatten-js/classes/circle.js","webpack://flatten-boolean-op/./node_modules/flatten-js/classes/segment.js","webpack://flatten-boolean-op/./node_modules/flatten-js/classes/arc.js","webpack://flatten-boolean-op/./node_modules/flatten-js/classes/box.js","webpack://flatten-boolean-op/./node_modules/flatten-js/classes/edge.js","webpack://flatten-boolean-op/./node_modules/flatten-js/classes/face.js","webpack://flatten-boolean-op/./node_modules/flatten-js/classes/ray.js","webpack://flatten-boolean-op/./node_modules/flatten-js/algorithms/ray_shooting.js","webpack://flatten-boolean-op/./node_modules/flatten-js/classes/polygon.js","webpack://flatten-boolean-op/./node_modules/flatten-js/algorithms/distance.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Node","RB_TREE_COLOR_RED","RB_TREE_COLOR_BLACK","nil_node","[object Object]","this","size","count","tree_walk","keys","res","node","push","item","output","isEmpty","undefined","insert_node","tree_insert","recalc_max","search_node","tree_search","delete_node","tree_delete","interval","resp_nodes","tree_search_interval","resp","forEach","visitor","node_current","parent","update_max","current_node","parent_node","less_than","left","right","insert_fixup","uncle_node","color","rotate_left","rotate_right","cut_node","fix_node","tree_successor","copy_data","delete_fixup","brother_node","equal_to","not_intersect_left_subtree","intersect","not_intersect_right_subtree","node_min","node_max","node_successor","local_minimum","x","y","action","height","heightLeft","heightRight","testBlackHeightProperty","Error","Flatten","Polygon","Segment","Arc","NOT_VERTEX","START_VERTEX","END_VERTEX","BooleanOp","operands","res_poly","wrk_poly","op","booleanOpBinary","clip","polygon1","polygon2","BOOLEAN_UNION","wrk_poly_reversed","clone","reverse","BOOLEAN_SUBTRACT","BOOLEAN_INTERSECT","intersections","getIntersections","sortIntersections","splitByIntersections","int_points1_sorted","int_points2_sorted","filterDuplicatedIntersections","notIntersectedFacesRes","getNotIntersectedFaces","int_points1","notIntersectedFacesWrk","int_points2","calcInclusionForNotIntersectedFaces","initializeInclusionFlags","calculateInclusionFlags","setOverlappingFlags","removeNotRelevantFaces","removeNotRelevantNotIntersectedFaces","copyWrkToRes","swapLinks","removeOldFaces","restoreFaces","edge1","edges","search","box","edge2","ip","shape","pt","addToIntPoints","edge","int_points","id","length","split","len","start","equalTo","end","is_vertex","Utils","EQ","arc_length","next","edge_before","edge_after","face","getSortedArray","faceMap","Map","has","set","faceId","slice","sort","compareFn","ip1","ip2","LT","GT","polygon","int_point","prev","newEdge","addVertex","do_squeeze","int_point_ref1","int_point_ref2","int_point_cur1","int_point_cur2","filter","index","poly","notIntersected","faces","find","notIntersectedFaces","poly2","first","bv","bvStart","bvEnd","setInclusion","overlap","BOUNDARY","cur_face","first_int_point_in_face","next_int_point1","num_int_points","cur_int_point1","edge_from1","edge_to1","cur_int_point2","next_int_point2","edge_from2","edge_to2","setOverlap","is_res_polygon","int_point_current","int_point_next","first_int_point_in_face_num","next_int_point_num","int_points_from_pull_start","int_points_from_pull_num","intPointsPullCount","int_points_to_pull_start","int_points_to_pull_num","edge_from","edge_to","INSIDE","OUTSIDE","OVERLAP_SAME","OVERLAP_OPPOSITE","removeChain","k","cur_int_point_num","int_points_pull_num","res_polygon","wrk_polygon","add","addFace","last","int_point1","int_point2","delete","other_int_points","int_point_tmp","rel","deleteFace","Errors","f","DP_TOL","CCW","CW","ORIENTATION","NOT_ORIENTABLE","PIx2","Math","PI","CONTAINS","INTERLACE","EQ_0","GE","LE","ILLEGAL_PARAMETERS","ReferenceError","ZERO_DIVISION","Matrix","a","b","tx","ty","vector","other_matrix","args","Vector","multiply","angle","cos","sin","sx","sy","matrix","IntervalTree","PlanarSet","Set","super","insert","deleted","remove","clear","point","Box","on","reduce","acc","svg","Interval","Array","Number","isNaN","min","max","other_node","value_equal","maximal_val","val_less_than","high","low","other_interval","not_intersect","val1","val2","Point","arr","vertices","center","x_rot","y_rot","transform","line","vec","cross","norm","dist","dot","proj_vec","translate","Distance","dx","dy","sqrt","Line","point2line","Circle","point2circle","point2segment","point2arc","point2polygon","shape2planarSet","contains","attrs","stroke","strokeWidth","fill","className","id_str","class_str","assign","a1","a2","slope","atan2","v","scalar","rpoint","rotate","norm1","normalize","norm2","points2norm","standard","other_line","parallelTo","intersectLine2Line","intersectLine2Circle","intersectLine2Arc","intersectLine2Polygon","distance","shortest_segment","circle2line","segment2line","arc2line","shape2polygon","intersectLine2Box","ps","pe","pt1","pt2","rotate90CCW","line1","line2","A1","B1","C1","A2","B2","C2","det","detX","detY","new_ip","circle","prj","pc","projectionOn","distanceTo","v_trans","delta","rotate90CW","pts","xmin","ymin","xmax","ymax","segs","ips","seg","ips_tmp","arc","ip_tmp","counterclockwise","intersectCirle2Circle","intersectShape2Polygon","circle2circle","segment2circle","arc2circle","circle1","circle2","r1","r2","abs","mid_pt","h","fillOpacity","coords","distanceToPoint","intersectSegment2Line","intersectSegment2Segment","intersectSegment2Circle","intersectSegment2Arc","segment2segment","segment2arc","rest","isZeroLength","leftTo","seg1","seg2","incidentTo","segment","startAngle","endAngle","counterClockwise","sweep","breakToFunctional","merge","test_arc","intersectArc2Circle","intersectArc2Arc","arc2arc","func_arcs_array","angles","test_arcs","arc1","arc2","new_arc","prev_arc","newStart","newEnd","newCenter","arcSE","circularSegmentDefiniteIntegral","onLeftSide","areaTrapez","definiteIntegral","areaCircularSegment","circularSegmentArea","largeArcFlag","sweepFlag","other_box","lessThan","box1","box2","width","Edge","middle","ray_shoot","bvMiddle","flag","shape1","shape2","sign","halfArc1","halfArc2","toJSON","Face","_box","_orientation","shapes","every","segments","points2segments","shapes2face","flattenShapes","flattenShape","toArc","setArcLength","iterator","done","face_edges","counter","points","append","edgeBefore","edgeAfter","edge_tmp","orientation","signedArea","sArea","area","getSelfIntersections","exitOnFirst","map","svgStr","Ray","POSITIVE_INFINITY","intersectRay2Segment","intersectRay2Arc","ray","resp_edges","i1","i2","intersection","prev_edge","prev_tangent","tangentInEnd","prev_point","cur_tangent","tangentInStart","cur_point","prev_on_the_left","cur_on_the_left","next_edge","next_tangent","next_point","next_on_the_left","edgeFrom","edgeTo","min_dist_and_segment","min_stop","intersectPolygon2Polygon","valid","isSimple","newPolygon","fillRule","closest_point","dist2center","shortest_dist","point2point","v_seg","v_ps2pt","v_pe2pt","start_sp","end_sp","v_unit","dist_and_segment","dist_from_start","shortest_segment_from_start","dist_from_end","shortest_segment_from_end","dist_from_center","shortest_segment_from_center","dist_from_projection","shortest_segment_from_projection","dist_tmp","segment_tmp","mindist_x","mindist_y","mindist","level","tree","maxdist","box2box_minmax","new_level","isNil","minmax_tree_process_level","squared_min_stop","min_dist_and_segment_new","stop","minmax_tree_calc_distance","minmax_tree","d1","d2"],"mappings":"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","file":"flatten-boolean-op.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"flatten-boolean-op\"] = factory();\n\telse\n\t\troot[\"flatten-boolean-op\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","/**\r\n * Created by Alex Bol on 3/31/2017.\r\n */\r\n'use strict';\r\n\r\nlet Node = require('./classes/node');\r\nlet {RB_TREE_COLOR_RED, RB_TREE_COLOR_BLACK} = require('./utils/constants');\r\n\r\nlet nil_node = new Node();\r\n\r\n/**\r\n * Implementation of interval binary search tree <br/>\r\n * Interval tree may store items which are couples of {key:interval, value: value} <br/>\r\n * Interval is an object with high and low properties or simply array of numeric [low,high] values <br />\r\n * If interval is an object, it should implement and expose methods less_than, equals_to, intersect and others,\r\n * see documentation {link}\r\n * @type {IntervalTree}\r\n */\r\nlet IntervalTree = class IntervalTree {\r\n    /**\r\n     * Construct new empty instance of IntervalTree\r\n     */\r\n    constructor() {\r\n        this.root = null;\r\n    }\r\n\r\n    /**\r\n     * Returns number of items stored in the interval tree\r\n     * @returns {number}\r\n     */\r\n    get size() {\r\n        let count = 0;\r\n        this.tree_walk(this.root, () => count++);\r\n        return count;\r\n    }\r\n\r\n    get keys() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push(node.item.key.output()));\r\n        return res;\r\n    }\r\n\r\n    get isEmpty() {\r\n        return (this.root == null || this.root == nil_node);\r\n    }\r\n\r\n    /**\r\n     * Insert new item into interval tree\r\n     * @param key - interval object or array of two numbers [low, high]\r\n     * @param value - value representing any object (optional)\r\n     * @returns {Node} - returns reference to inserted node as an object {key:interval, value: value}\r\n     */\r\n    insert(key, value = key) {\r\n        if (key === undefined) return;\r\n        let insert_node = new Node(key, value, nil_node, nil_node, null, RB_TREE_COLOR_RED);\r\n        this.tree_insert(insert_node);\r\n        this.recalc_max(insert_node);\r\n        return insert_node;\r\n    }\r\n\r\n    /**\r\n     * Returns true if item {key,value} exist in the tree\r\n     * @param key - interval correspondent to keys stored in the tree\r\n     * @param value - value object to be checked\r\n     * @returns {boolean} - true if item {key, value} exist in the tree, false otherwise\r\n     */\r\n    exist(key, value) {\r\n        let search_node = new Node(key, value);\r\n        return this.tree_search(this.root, search_node) ? true : false;\r\n    }\r\n\r\n    /**\r\n     * Remove entry {key, value} from the tree\r\n     * @param key - interval correspondent to keys stored in the tree\r\n     * @param value - - value object\r\n     * @returns {boolean} - true if item {key, value} deleted, false if not found\r\n     */\r\n    remove(key, value) {\r\n        let search_node = new Node(key, value);\r\n        let delete_node = this.tree_search(this.root, search_node);\r\n        if (delete_node) {\r\n            this.tree_delete(delete_node);\r\n        }\r\n        return delete_node;\r\n    }\r\n\r\n    /**\r\n     * Returns array of entry values which keys intersect with given interval <br/>\r\n     * If no values stored in the tree, returns array of keys which intersect given interval\r\n     * @param interval - search interval, or array [low, high]\r\n     * @returns {Array}\r\n     */\r\n    search(interval) {\r\n        let search_node = new Node(interval);\r\n        let resp_nodes = [];\r\n        this.tree_search_interval(this.root, search_node, resp_nodes);\r\n        let resp = [];\r\n        resp_nodes.forEach((node) => {\r\n            if (node.item.value) {         // if there are values, return only values\r\n                resp.push(node.item.value);\r\n            }\r\n            else {                         // otherwise, return keys\r\n                resp.push(node.item.key.output());\r\n            }\r\n        }, []);\r\n        return resp;\r\n    }\r\n\r\n    /**\r\n     * Tree visitor. For each node implement a callback function. <br/>\r\n     * Method calls a callback function with two parameters (key, value)\r\n     * @param visitor(key,value) - function to be called for each tree item\r\n     */\r\n    forEach(visitor) {\r\n        this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));\r\n    };\r\n\r\n    recalc_max(node) {\r\n        let node_current = node;\r\n        while (node_current.parent != null) {\r\n            node_current.parent.update_max();\r\n            node_current = node_current.parent;\r\n        }\r\n    }\r\n\r\n    tree_insert(insert_node) {\r\n        let current_node = this.root;\r\n        let parent_node = null;\r\n\r\n        if (this.root == null || this.root == nil_node) {\r\n            this.root = insert_node;\r\n        }\r\n        else {\r\n            while (current_node != nil_node) {\r\n                parent_node = current_node;\r\n                if (insert_node.less_than(current_node)) {\r\n                    current_node = current_node.left;\r\n                }\r\n                else {\r\n                    current_node = current_node.right;\r\n                }\r\n            }\r\n\r\n            insert_node.parent = parent_node;\r\n\r\n            if (insert_node.less_than(parent_node)) {\r\n                parent_node.left = insert_node;\r\n            }\r\n            else {\r\n                parent_node.right = insert_node;\r\n            }\r\n        }\r\n\r\n        this.insert_fixup(insert_node);\r\n    }\r\n\r\n// After insertion insert_node may have red-colored parent, and this is a single possible violation\r\n// Go upwords to the root and re-color until violation will be resolved\r\n    insert_fixup(insert_node) {\r\n        let current_node;\r\n        let uncle_node;\r\n\r\n        current_node = insert_node;\r\n        while (current_node != this.root && current_node.parent.color == RB_TREE_COLOR_RED) {\r\n            if (current_node.parent == current_node.parent.parent.left) {   // parent is left child of grandfather\r\n                uncle_node = current_node.parent.parent.right;              // right brother of parent\r\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 1. Uncle is red\r\n                    // re-color father and uncle into black\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    current_node = current_node.parent.parent;\r\n                }\r\n                else {                                                    // Case 2 & 3. Uncle is black\r\n                    if (current_node == current_node.parent.right) {     // Case 2. Current if right child\r\n                        // This case is transformed into Case 3.\r\n                        current_node = current_node.parent;\r\n                        this.rotate_left(current_node);\r\n                    }\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 3. Current is left child.\r\n                    // Re-color father and grandfather, rotate grandfather right\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    this.rotate_right(current_node.parent.parent);\r\n                }\r\n            }\r\n            else {                                                         // parent is right child of grandfather\r\n                uncle_node = current_node.parent.parent.left;              // left brother of parent\r\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 4. Uncle is red\r\n                    // re-color father and uncle into black\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    current_node = current_node.parent.parent;\r\n                }\r\n                else {\r\n                    if (current_node == current_node.parent.left) {             // Case 5. Current is left child\r\n                        // Transform into case 6\r\n                        current_node = current_node.parent;\r\n                        this.rotate_right(current_node);\r\n                    }\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 6. Current is right child.\r\n                    // Re-color father and grandfather, rotate grandfather left\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    this.rotate_left(current_node.parent.parent);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.root.color = RB_TREE_COLOR_BLACK;\r\n    }\r\n\r\n    tree_delete(delete_node) {\r\n        let cut_node;   // node to be cut - either delete_node or successor_node  (\"y\" from 14.4)\r\n        let fix_node;   // node to fix rb tree property   (\"x\" from 14.4)\r\n\r\n        if (delete_node.left == nil_node || delete_node.right == nil_node) {  // delete_node has less then 2 children\r\n            cut_node = delete_node;\r\n        }\r\n        else {                                                    // delete_node has 2 children\r\n            cut_node = this.tree_successor(delete_node);\r\n        }\r\n\r\n        // fix_node if single child of cut_node\r\n        if (cut_node.left != nil_node) {\r\n            fix_node = cut_node.left;\r\n        }\r\n        else {\r\n            fix_node = cut_node.right;\r\n        }\r\n\r\n        // remove cut_node from parent\r\n        /*if (fix_node != nil_node) {*/\r\n            fix_node.parent = cut_node.parent;\r\n        /*}*/\r\n\r\n        if (cut_node == this.root) {\r\n            this.root = fix_node;\r\n        }\r\n        else {\r\n            if (cut_node == cut_node.parent.left) {\r\n                cut_node.parent.left = fix_node;\r\n            }\r\n            else {\r\n                cut_node.parent.right = fix_node;\r\n            }\r\n            cut_node.parent.update_max();        // update max property of the parent\r\n        }\r\n\r\n        this.recalc_max(fix_node);              // update max property upward from fix_node to root\r\n\r\n        // COPY DATA !!!\r\n        // Delete_node becomes cut_node, it means that we cannot hold reference\r\n        // to node in outer structure and we will have to delete by key, additional search need\r\n        if (cut_node != delete_node) {\r\n            delete_node.copy_data(cut_node);\r\n            delete_node.update_max();           // update max property of the cut node at the new place\r\n            this.recalc_max(delete_node);       // update max property upward from delete_node to root\r\n        }\r\n\r\n        if (/*fix_node != nil_node && */cut_node.color == RB_TREE_COLOR_BLACK) {\r\n            this.delete_fixup(fix_node);\r\n        }\r\n    }\r\n\r\n    delete_fixup(fix_node) {\r\n        let current_node = fix_node;\r\n        let brother_node;\r\n\r\n        while (current_node != this.root && current_node.parent != null && current_node.color == RB_TREE_COLOR_BLACK) {\r\n            if (current_node == current_node.parent.left) {          // fix node is left child\r\n                brother_node = current_node.parent.right;\r\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\r\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\r\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\r\n                    this.rotate_left(current_node.parent);\r\n                    brother_node = current_node.parent.right;                      // update brother\r\n                }\r\n                // Derive to cases 2..4: brother is black\r\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\r\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {  // case 2: both nephews black\r\n                    brother_node.color = RB_TREE_COLOR_RED;              // re-color brother\r\n                    current_node = current_node.parent;                  // continue iteration\r\n                }\r\n                else {\r\n                    if (brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 3: left nephew red, right nephew black\r\n                        brother_node.color = RB_TREE_COLOR_RED;          // re-color brother\r\n                        brother_node.left.color = RB_TREE_COLOR_BLACK;   // re-color nephew\r\n                        this.rotate_right(brother_node);\r\n                        brother_node = current_node.parent.right;                     // update brother\r\n                        // Derive to case 4: left nephew black, right nephew red\r\n                    }\r\n                    // case 4: left nephew black, right nephew red\r\n                    brother_node.color = current_node.parent.color;\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    brother_node.right.color = RB_TREE_COLOR_BLACK;\r\n                    this.rotate_left(current_node.parent);\r\n                    current_node = this.root;                         // exit from loop\r\n                }\r\n            }\r\n            else {                                             // fix node is right child\r\n                brother_node = current_node.parent.left;\r\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\r\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\r\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\r\n                    this.rotate_right(current_node.parent);\r\n                    brother_node = current_node.parent.left;                        // update brother\r\n                }\r\n                // Go to cases 2..4\r\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\r\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 2\r\n                    brother_node.color = RB_TREE_COLOR_RED;             // re-color brother\r\n                    current_node = current_node.parent;                              // continue iteration\r\n                }\r\n                else {\r\n                    if (brother_node.left.color == RB_TREE_COLOR_BLACK) {  // case 3: right nephew red, left nephew black\r\n                        brother_node.color = RB_TREE_COLOR_RED;            // re-color brother\r\n                        brother_node.right.color = RB_TREE_COLOR_BLACK;    // re-color nephew\r\n                        this.rotate_left(brother_node);\r\n                        brother_node = current_node.parent.left;                        // update brother\r\n                        // Derive to case 4: right nephew black, left nephew red\r\n                    }\r\n                    // case 4: right nephew black, left nephew red\r\n                    brother_node.color = current_node.parent.color;\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    brother_node.left.color = RB_TREE_COLOR_BLACK;\r\n                    this.rotate_right(current_node.parent);\r\n                    current_node = this.root;                               // force exit from loop\r\n                }\r\n            }\r\n        }\r\n\r\n        current_node.color = RB_TREE_COLOR_BLACK;\r\n    }\r\n\r\n    tree_search(node, search_node) {\r\n        if (node == null || node == nil_node)\r\n            return undefined;\r\n\r\n        if (search_node.equal_to(node)) {\r\n            return node;\r\n        }\r\n        if (search_node.less_than(node)) {\r\n            return this.tree_search(node.left, search_node);\r\n        }\r\n        else {\r\n            return this.tree_search(node.right, search_node);\r\n        }\r\n    }\r\n\r\n    // Original search_interval method; container res support push() insertion\r\n    // Search all intervals intersecting given one\r\n    tree_search_interval(node, search_node, res) {\r\n        if (node != null && node != nil_node) {\r\n            // if (node->left != nil_node && node->left->max >= low) {\r\n            if (node.left != nil_node && !node.not_intersect_left_subtree(search_node)) {\r\n                this.tree_search_interval(node.left, search_node, res);\r\n            }\r\n            // if (low <= node->high && node->low <= high) {\r\n            if (node.intersect(search_node)) {\r\n                res.push(node);\r\n            }\r\n            // if (node->right != nil_node && node->low <= high) {\r\n            if (node.right != nil_node && !node.not_intersect_right_subtree(search_node)) {\r\n                this.tree_search_interval(node.right, search_node, res);\r\n            }\r\n        }\r\n    }\r\n\r\n    local_minimum(node) {\r\n        let node_min = node;\r\n        while (node_min.left != null && node_min.left != nil_node) {\r\n            node_min = node_min.left;\r\n        }\r\n        return node_min;\r\n    }\r\n\r\n    // not in use\r\n    local_maximum(node) {\r\n        let node_max = node;\r\n        while (node_max.right != null && node_max.right != nil_node) {\r\n            node_max = node_max.right;\r\n        }\r\n        return node_max;\r\n    }\r\n\r\n    tree_successor(node) {\r\n        let node_successor;\r\n        let current_node;\r\n        let parent_node;\r\n\r\n        if (node.right != nil_node) {\r\n            node_successor = this.local_minimum(node.right);\r\n        }\r\n        else {\r\n            current_node = node;\r\n            parent_node = node.parent;\r\n            while (parent_node != null && parent_node.right == current_node) {\r\n                current_node = parent_node;\r\n                parent_node = parent_node.parent;\r\n            }\r\n            node_successor = parent_node;\r\n        }\r\n        return node_successor;\r\n    }\r\n\r\n    //           |            right-rotate(T,y)       |\r\n    //           y            ---------------.       x\r\n    //          / \\                                  / \\\r\n    //         x   c          left-rotate(T,x)      a   y\r\n    //        / \\             <---------------         / \\\r\n    //       a   b                                    b   c\r\n\r\n    rotate_left(x) {\r\n        let y = x.right;\r\n\r\n        x.right = y.left;           // b goes to x.right\r\n\r\n        if (y.left != nil_node) {\r\n            y.left.parent = x;     // x becomes parent of b\r\n        }\r\n        y.parent = x.parent;       // move parent\r\n\r\n        if (x == this.root) {\r\n            this.root = y;           // y becomes root\r\n        }\r\n        else {                        // y becomes child of x.parent\r\n            if (x == x.parent.left) {\r\n                x.parent.left = y;\r\n            }\r\n            else {\r\n                x.parent.right = y;\r\n            }\r\n        }\r\n        y.left = x;                 // x becomes left child of y\r\n        x.parent = y;               // and y becomes parent of x\r\n\r\n        if (x != null && x != nil_node) {\r\n            x.update_max();\r\n        }\r\n\r\n        y = x.parent;\r\n        if (y != null && y != nil_node) {\r\n            y.update_max();\r\n        }\r\n    }\r\n\r\n    rotate_right(y) {\r\n        let x = y.left;\r\n\r\n        y.left = x.right;           // b goes to y.left\r\n\r\n        if (x.right != nil_node) {\r\n            x.right.parent = y;        // y becomes parent of b\r\n        }\r\n        x.parent = y.parent;          // move parent\r\n\r\n        if (y == this.root) {        // x becomes root\r\n            this.root = x;\r\n        }\r\n        else {                        // y becomes child of x.parent\r\n            if (y == y.parent.left) {\r\n                y.parent.left = x;\r\n            }\r\n            else {\r\n                y.parent.right = x;\r\n            }\r\n        }\r\n        x.right = y;                 // y becomes right child of x\r\n        y.parent = x;               // and x becomes parent of y\r\n\r\n        if (y != null && y != nil_node) {\r\n            y.update_max();\r\n        }\r\n\r\n        x = y.parent;\r\n        if (x != null && x != nil_node) {\r\n            x.update_max();\r\n        }\r\n    }\r\n\r\n    tree_walk(node, action) {\r\n        if (node != null && node != nil_node) {\r\n            this.tree_walk(node.left, action);\r\n            // arr.push(node.toArray());\r\n            action(node);\r\n            this.tree_walk(node.right, action);\r\n        }\r\n    }\r\n\r\n    /* Return true if all red nodes have exactly two black child nodes */\r\n    testRedBlackProperty() {\r\n        let res = true;\r\n        this.tree_walk(this.root, function (node) {\r\n            if (node.color == RB_TREE_COLOR_RED) {\r\n                if (!(node.left.color == RB_TREE_COLOR_BLACK && node.right.color == RB_TREE_COLOR_BLACK)) {\r\n                    res = false;\r\n                }\r\n            }\r\n        });\r\n        return res;\r\n    }\r\n\r\n    /* Throw error if not every path from root to bottom has same black height */\r\n    testBlackHeightProperty(node) {\r\n        let height = 0;\r\n        let heightLeft = 0;\r\n        let heightRight = 0;\r\n        if (node.color == RB_TREE_COLOR_BLACK) {\r\n            height++;\r\n        }\r\n        if (node.left != nil_node) {\r\n            heightLeft = this.testBlackHeightProperty(node.left);\r\n        }\r\n        else {\r\n            heightLeft = 1;\r\n        }\r\n        if (node.right != nil_node) {\r\n            heightRight = this.testBlackHeightProperty(node.right);\r\n        }\r\n        else {\r\n            heightRight = 1;\r\n        }\r\n        if (heightLeft != heightRight) {\r\n            throw new Error('Red-black height property violated');\r\n        }\r\n        height += heightLeft;\r\n        return height;\r\n    };\r\n};\r\n\r\nmodule.exports = IntervalTree;\r\n","/**\r\n * Created by Alex Bol on 3/28/2017.\r\n */\r\n\r\n'use strict';\r\n\r\nmodule.exports = {\r\n    RB_TREE_COLOR_RED: 0,\r\n    RB_TREE_COLOR_BLACK: 1\r\n};","/**\r\n * Created by Alex Bol on 12/02/2018.\r\n */\r\n\"use strict\";\r\nlet Flatten = require(\"flatten-js\");\r\n// let Flatten = require(\"flatten-js/dist/flatten.min\");\r\nlet {Polygon, Segment, Arc} = Flatten;\r\n\r\nconst NOT_VERTEX = 0;\r\nconst START_VERTEX = 1;\r\nconst END_VERTEX = 2;\r\n\r\n/**\r\n * Class BooleanOp implements boolean operations on polygons\r\n */\r\nclass BooleanOp {\r\n    static booleanOp(operands) {\r\n        let res_poly = new Polygon();\r\n        for (let [wrk_poly, op] of operands) {\r\n            res_poly = BooleanOp.booleanOpBinary(res_poly, wrk_poly, op);\r\n        }\r\n        return res_poly;\r\n    }\r\n\r\n    static booleanOpBinary(res_poly, wrk_poly, op) {\r\n        return BooleanOp.clip(res_poly, wrk_poly, op);\r\n    }\r\n\r\n    /**\r\n     * Unify two polygons polygons and returns new polygon. <br/>\r\n     * Point belongs to the resulted polygon if it belongs to the first OR to the second polygon\r\n     * @param {Flatten.Polygon} polygon1 - first operand\r\n     * @param {Flatten.Polygon} polygon2 - second operand\r\n     * @returns {Flatten.Polygon}\r\n     */\r\n    static unify(polygon1, polygon2) {\r\n        let res_poly = BooleanOp.booleanOpBinary(polygon1, polygon2, BooleanOp.BOOLEAN_UNION);\r\n        return res_poly;\r\n    }\r\n\r\n    /**\r\n     * Subtract second polygon from the first and returns new polygon\r\n     * Point belongs to the resulted polygon if it belongs to the first polygon AND NOT to the second polygon\r\n     * @param {Flatten.Polygon} polygon1 - first operand\r\n     * @param {Flatten.Polygon} polygon2 - second operand\r\n     * @returns {Flatten.Polygon}\r\n     */\r\n    static subtract(polygon1, polygon2) {\r\n        let wrk_poly = polygon2.clone();\r\n        let wrk_poly_reversed = wrk_poly.reverse();\r\n        let res_poly = BooleanOp.booleanOpBinary(polygon1, wrk_poly_reversed, BooleanOp.BOOLEAN_SUBTRACT);\r\n        return res_poly;\r\n    }\r\n\r\n    /**\r\n     * Intersect two polygons and returns new polygon\r\n     * Point belongs to the resultes polygon is it belongs to the first AND to the second polygon\r\n     * @param {Flatten.Polygon} polygon1 - first operand\r\n     * @param {Flatten.Polygon} polygon2 - second operand\r\n     * @returns {Flatten.Polygon}\r\n     */\r\n    static intersect(polygon1, polygon2) {\r\n        let res_poly = BooleanOp.booleanOpBinary(polygon1, polygon2, BooleanOp.BOOLEAN_INTERSECT);\r\n        return res_poly;\r\n    }\r\n\r\n    static arrange(polygon1, polygon2) {\r\n        // get intersection points\r\n        let intersections = BooleanOp.getIntersections(polygon1, polygon2);\r\n\r\n        // sort intersection points\r\n        BooleanOp.sortIntersections(intersections);\r\n\r\n        // split by intersection points\r\n        BooleanOp.splitByIntersections(polygon1, intersections.int_points1_sorted);\r\n        BooleanOp.splitByIntersections(polygon2, intersections.int_points2_sorted);\r\n    }\r\n\r\n    static clip(polygon1, polygon2, op) {\r\n        let res_poly = polygon1.clone();\r\n        let wrk_poly = polygon2.clone();\r\n\r\n        // get intersection points\r\n        let intersections = BooleanOp.getIntersections(res_poly, wrk_poly);\r\n\r\n        // sort intersection points\r\n        BooleanOp.sortIntersections(intersections);\r\n\r\n        // split by intersection points\r\n        BooleanOp.splitByIntersections(res_poly, intersections.int_points1_sorted);\r\n        BooleanOp.splitByIntersections(wrk_poly, intersections.int_points2_sorted);\r\n\r\n        // filter duplicated intersection points\r\n        BooleanOp.filterDuplicatedIntersections(intersections);\r\n\r\n        // keep not intersected faces for further remove and merge\r\n        let notIntersectedFacesRes = BooleanOp.getNotIntersectedFaces(res_poly, intersections.int_points1);\r\n        let notIntersectedFacesWrk = BooleanOp.getNotIntersectedFaces(wrk_poly, intersections.int_points2);\r\n\r\n        // calculate inclusion flag for not intersected faces\r\n        BooleanOp.calcInclusionForNotIntersectedFaces(notIntersectedFacesRes, wrk_poly);\r\n        BooleanOp.calcInclusionForNotIntersectedFaces(notIntersectedFacesWrk, res_poly);\r\n\r\n        // initialize inclusion flags for edges incident to intersections\r\n        BooleanOp.initializeInclusionFlags(intersections.int_points1);\r\n        BooleanOp.initializeInclusionFlags(intersections.int_points2);\r\n\r\n        // calculate inclusion flags only for edges incident to intersections\r\n        BooleanOp.calculateInclusionFlags(intersections.int_points1, polygon2);\r\n        BooleanOp.calculateInclusionFlags(intersections.int_points2, polygon1);\r\n\r\n        // TODO: fix bondary conflicts\r\n\r\n        // Set overlapping flags for boundary chains: SAME or OPPOSITE\r\n        BooleanOp.setOverlappingFlags(intersections);\r\n\r\n        // remove not relevant faces between intersection points\r\n        BooleanOp.removeNotRelevantFaces(res_poly, op, intersections.int_points1_sorted, true);\r\n        BooleanOp.removeNotRelevantFaces(wrk_poly, op, intersections.int_points2_sorted, false);\r\n\r\n        // remove not relevant not intersected faces from res_polygon and wrk_polygon\r\n        // if op == UNION, remove faces that are included in wrk_polygon without intersection\r\n        // if op == INTERSECT, remove faces that are not included into wrk_polygon\r\n        BooleanOp.removeNotRelevantNotIntersectedFaces(res_poly, notIntersectedFacesRes, op,true);\r\n        BooleanOp.removeNotRelevantNotIntersectedFaces(wrk_poly, notIntersectedFacesWrk, op,false);\r\n\r\n        // add edges of wrk_poly into the edge container of res_poly\r\n        BooleanOp.copyWrkToRes(res_poly, wrk_poly, op, intersections.int_points2);\r\n\r\n        // swap links from res_poly to wrk_poly and vice versa\r\n        BooleanOp.swapLinks(res_poly, wrk_poly, intersections);\r\n\r\n        // remove old faces\r\n        BooleanOp.removeOldFaces(res_poly, intersections.int_points1);\r\n        BooleanOp.removeOldFaces(wrk_poly, intersections.int_points2);\r\n\r\n        // restore faces\r\n        BooleanOp.restoreFaces(res_poly, intersections.int_points1, intersections.int_points2);\r\n        BooleanOp.restoreFaces(res_poly, intersections.int_points2, intersections.int_points1);\r\n\r\n        // merge relevant not intersected faces from wrk_polygon to res_polygon\r\n        // BooleanOp.mergeRelevantNotIntersectedFaces(res_poly, wrk_poly);\r\n\r\n        return res_poly;\r\n    }\r\n\r\n    static getIntersections(polygon1, polygon2) {\r\n        let intersections = {\r\n            int_points1: [],\r\n            int_points2: []\r\n        };\r\n\r\n        // calculate intersections\r\n        for (let edge1 of polygon1.edges) {\r\n\r\n            // request edges of polygon2 in the box of edge1\r\n            let resp = polygon2.edges.search(edge1.box);\r\n\r\n            // for each edge2 in response\r\n            for (let edge2 of resp) {\r\n\r\n                // calculate intersections between edge1 and edge2\r\n                let ip = edge1.shape.intersect(edge2.shape);\r\n\r\n                // for each intersection point\r\n                for (let pt of ip) {\r\n                    BooleanOp.addToIntPoints(edge1, pt, intersections.int_points1);\r\n                    BooleanOp.addToIntPoints(edge2, pt, intersections.int_points2);\r\n                }\r\n            }\r\n        }\r\n        return intersections;\r\n    }\r\n\r\n    static addToIntPoints(edge, pt, int_points) {\r\n        let id = int_points.length;\r\n        let split = edge.shape.split(pt);\r\n        if (split.length === 0) return;     // Means point does not belong to edge\r\n        let len = 0;\r\n        if (split.length === 1) {           // Edge was not split\r\n            if (edge.shape.start.equalTo(pt)) {\r\n                len = 0;\r\n            } else if (edge.shape.end.equalTo(pt)) {\r\n                len = edge.shape.length;\r\n            }\r\n        } else {                             // Edge was split into to edges\r\n            len = split[0].length;\r\n        }\r\n        let is_vertex = NOT_VERTEX;\r\n        if (Flatten.Utils.EQ(len, 0)) {\r\n            is_vertex |= START_VERTEX;\r\n        }\r\n        if (Flatten.Utils.EQ(len, edge.shape.length)) {\r\n            is_vertex |= END_VERTEX;\r\n        }\r\n        // Fix intersection point which is end point of the last edge\r\n        let arc_length = (is_vertex & END_VERTEX) && edge.next.arc_length === 0 ? 0 : edge.arc_length + len;\r\n\r\n        int_points.push({\r\n            id: id,\r\n            pt: pt,\r\n            arc_length: arc_length,\r\n            edge_before: edge,\r\n            edge_after: undefined,\r\n            face: edge.face,\r\n            is_vertex: is_vertex\r\n        });\r\n    }\r\n\r\n    static sortIntersections(intersections) {\r\n        if (intersections.int_points1.length === 0) return;\r\n\r\n        // augment intersections with new sorted arrays\r\n        // intersections.int_points1_sorted = intersections.int_points1.slice().sort(BooleanOp.compareFn);\r\n        // intersections.int_points2_sorted = intersections.int_points2.slice().sort(BooleanOp.compareFn);\r\n        intersections.int_points1_sorted = BooleanOp.getSortedArray(intersections.int_points1);\r\n        intersections.int_points2_sorted = BooleanOp.getSortedArray(intersections.int_points2);\r\n    }\r\n\r\n    static getSortedArray(int_points) {\r\n        let faceMap = new Map;\r\n        let id = 0;\r\n        // Create integer id's for faces\r\n        for (let ip of int_points) {\r\n            if (!faceMap.has(ip.face)) {\r\n                faceMap.set(ip.face, id);\r\n                id++;\r\n            }\r\n        }\r\n        // Augment intersection points with face id's\r\n        for (let ip of int_points) {\r\n            ip.faceId = faceMap.get(ip.face);\r\n        }\r\n        // Clone and sort\r\n        let int_points_sorted = int_points.slice().sort(BooleanOp.compareFn);\r\n        return int_points_sorted;\r\n    }\r\n\r\n    static compareFn(ip1, ip2) {\r\n        // compare face id's\r\n        if (ip1.faceId < ip2.faceId) {\r\n            return -1;\r\n        }\r\n        if (ip1.faceId > ip2.faceId) {\r\n            return 1;\r\n        }\r\n        // same face - compare arc_length\r\n        if (Flatten.Utils.LT(ip1.arc_length, ip2.arc_length)) {\r\n            return -1;\r\n        }\r\n        if (Flatten.Utils.GT(ip1.arc_length, ip2.arc_length)) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    static splitByIntersections(polygon, int_points) {\r\n        let {Polygon, Segment, Arc} = Flatten;\r\n        if (!int_points) return;\r\n        for (let int_point of int_points) {\r\n            let edge = int_point.edge_before;\r\n\r\n            // recalculate vertex flag: it may be changed after previous split\r\n            if (edge.shape.start.equalTo(int_point.pt)) {\r\n                int_point.is_vertex |= START_VERTEX;\r\n            }\r\n            if (edge.shape.end.equalTo(int_point.pt)) {\r\n                int_point.is_vertex |= END_VERTEX;\r\n            }\r\n\r\n            if (int_point.is_vertex & START_VERTEX) {  // nothing to split\r\n                int_point.edge_before = edge.prev;\r\n                int_point.is_vertex = END_VERTEX;\r\n                continue;\r\n            }\r\n            if (int_point.is_vertex & END_VERTEX) {    // nothing to split\r\n                continue;\r\n            }\r\n\r\n            let newEdge = polygon.addVertex(int_point.pt, edge);\r\n            int_point.edge_before = newEdge;\r\n        }\r\n\r\n        for (let int_point of int_points) {\r\n            int_point.edge_after = int_point.edge_before.next;\r\n        }\r\n    }\r\n\r\n    static filterDuplicatedIntersections(intersections) {\r\n        if (intersections.int_points1.length < 2) return;\r\n\r\n        let do_squeeze = false;\r\n\r\n        let int_point_ref1 = intersections.int_points1_sorted[0];\r\n        let int_point_ref2 = intersections.int_points2[int_point_ref1.id];\r\n        for (let i = 1; i < intersections.int_points1_sorted.length; i++) {\r\n            let int_point_cur1 = intersections.int_points1_sorted[i];\r\n\r\n            if (!Flatten.Utils.EQ(int_point_cur1.arc_length, int_point_ref1.arc_length)) {\r\n                int_point_ref1 = int_point_cur1;\r\n                int_point_ref2 = intersections.int_points2[int_point_ref1.id];\r\n                continue;\r\n            }\r\n\r\n            /* Same length: int_point_cur1->arc_len == int_point_ref1->arc_len */\r\n            /* Ensure this is intersection between same edges from the same face */\r\n            let int_point_cur2 = intersections.int_points2[int_point_cur1.id];\r\n            if (int_point_cur1.edge_before === int_point_ref1.edge_before &&\r\n                int_point_cur1.edge_after === int_point_ref1.edge_after &&\r\n                int_point_cur2.edge_before === int_point_ref2.edge_before &&\r\n                int_point_cur2.edge_after === int_point_ref2.edge_after) {\r\n                int_point_cur1.id = -1;\r\n                /* to be deleted */\r\n                int_point_cur2.id = -1;\r\n                /* to be deleted */\r\n                do_squeeze = true;\r\n            }\r\n        }\r\n\r\n        int_point_ref2 = intersections.int_points2_sorted[0];\r\n        int_point_ref1 = intersections.int_points1[int_point_ref2.id];\r\n        for (let i = 1; i < intersections.int_points2_sorted.length; i++) {\r\n            let int_point_cur2 = intersections.int_points2_sorted[i];\r\n\r\n            if (int_point_cur2.id == -1) continue;\r\n            /* already deleted */\r\n\r\n            if (int_point_ref2.id == -1 || /* can't be reference if already deleted */\r\n                !(Flatten.Utils.EQ(int_point_cur2.arc_length, int_point_ref2.arc_length))) {\r\n                int_point_ref2 = int_point_cur2;\r\n                int_point_ref1 = intersections.int_points1[int_point_ref2.id];\r\n                continue;\r\n            }\r\n\r\n            let int_point_cur1 = intersections.int_points1[int_point_cur2.id];\r\n            if (int_point_cur1.edge_before === int_point_ref1.edge_before &&\r\n                int_point_cur1.edge_after === int_point_ref1.edge_after &&\r\n                int_point_cur2.edge_before === int_point_ref2.edge_before &&\r\n                int_point_cur2.edge_after === int_point_ref2.edge_after) {\r\n                int_point_cur1.id = -1;\r\n                /* to be deleted */\r\n                int_point_cur2.id = -1;\r\n                /* to be deleted */\r\n                do_squeeze = true;\r\n            }\r\n        }\r\n\r\n        if (do_squeeze) {\r\n            intersections.int_points1 = intersections.int_points1.filter((int_point) => int_point.id >= 0);\r\n            intersections.int_points2 = intersections.int_points2.filter((int_point) => int_point.id >= 0);\r\n\r\n            // update id's\r\n            intersections.int_points1.forEach((int_point, index) => int_point.id = index);\r\n            intersections.int_points2.forEach((int_point, index) => int_point.id = index);\r\n\r\n            // re-create sorted\r\n            intersections.int_points1_sorted = [];\r\n            intersections.int_points2_sorted = [];\r\n            BooleanOp.sortIntersections(intersections);\r\n        }\r\n    }\r\n\r\n    static getNotIntersectedFaces(poly, int_points) {\r\n        let notIntersected = [];\r\n        for (let face of poly.faces) {\r\n            if (!int_points.find((ip) => ip.face === face)) {\r\n                notIntersected.push(face);\r\n            }\r\n        }\r\n        return notIntersected;\r\n    }\r\n\r\n    static calcInclusionForNotIntersectedFaces(notIntersectedFaces, poly2) {\r\n        for (let face of notIntersectedFaces) {\r\n            face.first.bv = face.first.bvStart = face.first.bvEnd = undefined;\r\n            face.first.setInclusion(poly2);\r\n        }\r\n    }\r\n\r\n    static initializeInclusionFlags(int_points) {\r\n        for (let int_point of int_points) {\r\n            int_point.edge_before.bvStart = undefined;\r\n            int_point.edge_before.bvEnd = undefined;\r\n            int_point.edge_before.bv = undefined;\r\n            int_point.edge_before.overlap = undefined;\r\n\r\n            int_point.edge_after.bvStart = undefined;\r\n            int_point.edge_after.bvEnd = undefined;\r\n            int_point.edge_after.bv = undefined;\r\n            int_point.edge_after.overlap = undefined;\r\n        }\r\n\r\n        for (let int_point of int_points) {\r\n            int_point.edge_before.bvEnd = Flatten.BOUNDARY;\r\n            int_point.edge_after.bvStart = Flatten.BOUNDARY;\r\n        }\r\n    }\r\n\r\n    static calculateInclusionFlags(int_points, polygon) {\r\n        for (let int_point of int_points) {\r\n            int_point.edge_before.setInclusion(polygon);\r\n            int_point.edge_after.setInclusion(polygon);\r\n        }\r\n    }\r\n\r\n    static setOverlappingFlags(intersections) {\r\n        let cur_face = undefined;\r\n        let first_int_point_in_face = undefined;\r\n        let next_int_point1 = undefined;\r\n        let num_int_points = intersections.int_points1.length;\r\n\r\n        for (let i = 0; i < num_int_points; i++) {\r\n            let cur_int_point1 = intersections.int_points1_sorted[i];\r\n\r\n            // Find boundary chain in the polygon1\r\n            if (cur_int_point1.face !== cur_face) {                               // next chain started\r\n                first_int_point_in_face = cur_int_point1;\r\n                cur_face = cur_int_point1.face;\r\n            }\r\n\r\n            if (i + 1 === num_int_points) {                                         // last int point in array\r\n                next_int_point1 = first_int_point_in_face;\r\n            } else if (intersections.int_points1_sorted[i + 1].face !== cur_face) {   // last int point in chain\r\n                next_int_point1 = first_int_point_in_face;\r\n            } else {                                                                // not a last point in chain\r\n                next_int_point1 = intersections.int_points1_sorted[i + 1];\r\n            }\r\n\r\n            let edge_from1 = cur_int_point1.edge_after;\r\n            let edge_to1 = next_int_point1.edge_before;\r\n\r\n            if (!(edge_from1.bv === Flatten.BOUNDARY && edge_to1.bv === Flatten.BOUNDARY))      // not a boundary chain - skip\r\n                continue;\r\n\r\n            if (edge_from1 !== edge_to1)                    //  one edge chain    TODO: support complex case\r\n                continue;\r\n\r\n\r\n            /* Find boundary chain in polygon2 between same intersection points */\r\n            let cur_int_point2 = intersections.int_points2[cur_int_point1.id];\r\n            let next_int_point2 = intersections.int_points2[next_int_point1.id];\r\n\r\n            let edge_from2 = cur_int_point2.edge_after;\r\n            let edge_to2 = next_int_point2.edge_before;\r\n\r\n            /* if [edge_from2..edge_to2] is not a boundary chain, invert it */\r\n            /* check also that chain consist of one or two edges */\r\n            if (!(edge_from2.bv === Flatten.BOUNDARY && edge_to2.bv === Flatten.BOUNDARY && edge_from2 === edge_to2)) {\r\n                cur_int_point2 = intersections.int_points2[next_int_point1.id];\r\n                next_int_point2 = intersections.int_points2[cur_int_point1.id];\r\n\r\n                edge_from2 = cur_int_point2.edge_after;\r\n                edge_to2 = next_int_point2.edge_before;\r\n            }\r\n\r\n            if (!(edge_from2.bv === Flatten.BOUNDARY && edge_to2.bv === Flatten.BOUNDARY && edge_from2 === edge_to2))\r\n                continue;                           // not an overlapping chain - skip   TODO: fix boundary conflict\r\n\r\n            // Set overlapping flag - one-to-one case\r\n            edge_from1.setOverlap(edge_from2);\r\n        }\r\n    }\r\n\r\n    static removeNotRelevantFaces(polygon, op, int_points, is_res_polygon) {\r\n        if (!int_points) return;\r\n        let cur_face = undefined;\r\n        let first_int_point_in_face_num = undefined;\r\n        let int_point_current;\r\n        let int_point_next;\r\n\r\n        for (let i = 0; i < int_points.length; i++) {\r\n            int_point_current = int_points[i];\r\n\r\n            if (int_point_current.face !== cur_face) {   // next face started\r\n                first_int_point_in_face_num = i;\r\n                cur_face = int_point_current.face;\r\n            }\r\n\r\n            if (cur_face.isEmpty())                // ??\r\n                continue;\r\n\r\n            // Get next int point from the same face that current\r\n\r\n            // Count how many duplicated points with same <x,y> in \"points from\" pull ?\r\n            let int_points_from_pull_start = i;\r\n            let int_points_from_pull_num = BooleanOp.intPointsPullCount(int_points, i, cur_face);\r\n            let next_int_point_num;\r\n            if (int_points_from_pull_start + int_points_from_pull_num < int_points.length &&\r\n                int_points[int_points_from_pull_start + int_points_from_pull_num].face === int_point_current.face) {\r\n                next_int_point_num = int_points_from_pull_start + int_points_from_pull_num;\r\n            } else {                                         // get first point from the same face\r\n                next_int_point_num = first_int_point_in_face_num;\r\n            }\r\n            int_point_next = int_points[next_int_point_num];\r\n\r\n            /* Count how many duplicated points with same <x,y> in \"points to\" pull ? */\r\n            let int_points_to_pull_start = next_int_point_num;\r\n            let int_points_to_pull_num = BooleanOp.intPointsPullCount(int_points, int_points_to_pull_start, cur_face);\r\n\r\n\r\n            let edge_from = int_point_current.edge_after;\r\n            let edge_to = int_point_next.edge_before;\r\n\r\n            if ((edge_from.bv === Flatten.INSIDE && edge_to.bv === Flatten.INSIDE && op === BooleanOp.BOOLEAN_UNION) ||\r\n                (edge_from.bv === Flatten.OUTSIDE && edge_to.bv === Flatten.OUTSIDE && op === BooleanOp.BOOLEAN_INTERSECT) ||\r\n                ((edge_from.bv === Flatten.OUTSIDE || edge_to.bv === Flatten.OUTSIDE) && op === BooleanOp.BOOLEAN_SUBTRACT && !is_res_polygon) ||\r\n                ((edge_from.bv === Flatten.INSIDE || edge_to.bv === Flatten.INSIDE) && op === BooleanOp.BOOLEAN_SUBTRACT && is_res_polygon) ||\r\n                (edge_from.bv === Flatten.BOUNDARY && edge_to.bv === Flatten.BOUNDARY && (edge_from.overlap & Flatten.OVERLAP_SAME) && is_res_polygon) ||\r\n                (edge_from.bv === Flatten.BOUNDARY && edge_to.bv === Flatten.BOUNDARY && (edge_from.overlap & Flatten.OVERLAP_OPPOSITE))) {\r\n\r\n                polygon.removeChain(cur_face, edge_from, edge_to);\r\n\r\n                /* update all points in \"points from\" pull */\r\n                for (let k = int_points_from_pull_start; k < int_points_from_pull_start + int_points_from_pull_num; k++) {\r\n                    int_point_current.edge_after = undefined;\r\n                }\r\n\r\n                /* update all points in \"points to\" pull */\r\n                for (let k = int_points_to_pull_start; k < int_points_to_pull_start + int_points_to_pull_num; k++) {\r\n                    int_point_next.edge_before = undefined;\r\n                }\r\n            }\r\n\r\n            /* skip to the last point in \"points from\" group */\r\n            i += int_points_from_pull_num - 1;\r\n        }\r\n    };\r\n\r\n    static intPointsPullCount(int_points, cur_int_point_num, cur_face) {\r\n        let int_point_current;\r\n        let int_point_next;\r\n\r\n        let int_points_pull_num = 1;\r\n\r\n        if (int_points.length == 1) return 1;\r\n\r\n        int_point_current = int_points[cur_int_point_num];\r\n\r\n        for (let i = cur_int_point_num + 1; i < int_points.length; i++) {\r\n            if (int_point_current.face != cur_face) {      /* next face started */\r\n                break;\r\n            }\r\n\r\n            int_point_next = int_points[i];\r\n\r\n            if (!(int_point_next.pt.equalTo(int_point_current.pt) &&\r\n                int_point_next.edge_before === int_point_current.edge_before &&\r\n                int_point_next.edge_after === int_point_current.edge_after)) {\r\n                break;         /* next point is different - break and exit */\r\n            }\r\n\r\n            int_points_pull_num++;     /* duplicated intersection point - increase counter */\r\n        }\r\n        return int_points_pull_num;\r\n    }\r\n\r\n    static copyWrkToRes(res_polygon, wrk_polygon, op, int_points) {\r\n        for (let face of wrk_polygon.faces) {\r\n            for (let edge of face) {\r\n                res_polygon.edges.add(edge);\r\n            }\r\n            // If union - add face from wrk_polygon that is not intersected with res_polygon\r\n            if (op === BooleanOp.BOOLEAN_UNION &&\r\n                int_points && int_points.find((ip) => (ip.face === face)) === undefined) {\r\n                res_polygon.addFace(face.first, face.last);\r\n            }\r\n        }\r\n    }\r\n\r\n    static swapLinks(res_polygon, wrk_polygon, intersections) {\r\n        if (intersections.int_points1.length === 0) return;\r\n\r\n        for (let i = 0; i < intersections.int_points1.length; i++) {\r\n            let int_point1 = intersections.int_points1[i];\r\n            let int_point2 = intersections.int_points2[i];\r\n\r\n            // Simple case - find continuation on the other polygon\r\n\r\n            // Process edge from res_polygon\r\n            if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {    // swap need\r\n                if (int_point2.edge_before === undefined && int_point2.edge_after !== undefined) {  // simple case\r\n                    // Connect edges\r\n                    int_point1.edge_before.next = int_point2.edge_after;\r\n                    int_point2.edge_after.prev = int_point1.edge_before;\r\n\r\n                    // Fill in missed links in intersection points\r\n                    int_point1.edge_after = int_point2.edge_after;\r\n                    int_point2.edge_before = int_point1.edge_before;\r\n                }\r\n            }\r\n            // Process edge from wrk_polygon\r\n            if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {    // swap need\r\n                if (int_point1.edge_before === undefined && int_point1.edge_after !== undefined) {  // simple case\r\n                    // Connect edges\r\n                    int_point2.edge_before.next = int_point1.edge_after;\r\n                    int_point1.edge_after.prev = int_point2.edge_before;\r\n\r\n                    // Complete missed links\r\n                    int_point2.edge_after = int_point1.edge_after;\r\n                    int_point1.edge_before = int_point2.edge_before;\r\n                }\r\n            }\r\n\r\n            // Continuation not found - complex case\r\n            // Continuation will be found on the same polygon.\r\n            // It happens when intersection point is actually touching point\r\n            // Polygon1\r\n            if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {    // still swap need\r\n                for (let int_point of intersections.int_points1_sorted) {\r\n                    if (int_point === int_point1) continue;     // skip same\r\n                    if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\r\n                        if (int_point.pt.equalTo(int_point1.pt)) {\r\n                            // Connect edges\r\n                            int_point1.edge_before.next = int_point.edge_after;\r\n                            int_point.edge_after.prev = int_point1.edge_before;\r\n\r\n                            // Complete missed links\r\n                            int_point1.edge_after = int_point.edge_after;\r\n                            int_point.edge_before = int_point1.edge_before;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Polygon2\r\n            if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {    // still swap need\r\n                for (let int_point of intersections.int_points2_sorted) {\r\n                    if (int_point === int_point2) continue;     // skip same\r\n                    if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\r\n                        if (int_point.pt.equalTo(int_point2.pt)) {\r\n                            // Connect edges\r\n                            int_point2.edge_before.next = int_point.edge_after;\r\n                            int_point.edge_after.prev = int_point2.edge_before;\r\n\r\n                            // Complete missed links\r\n                            int_point2.edge_after = int_point.edge_after;\r\n                            int_point.edge_before = int_point2.edge_before;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Sanity check that no dead ends left\r\n    }\r\n\r\n    static removeOldFaces(polygon, int_points) {\r\n        for (let int_point of int_points) {\r\n            polygon.faces.delete(int_point.face);\r\n            int_point.face = undefined;\r\n            if (int_point.edge_before)\r\n                int_point.edge_before.face = undefined;\r\n            if (int_point.edge_after)\r\n                int_point.edge_after.face = undefined;\r\n        }\r\n    }\r\n\r\n    static restoreFaces(polygon, int_points, other_int_points) {\r\n        // For each intersection point - create new face\r\n        for (let int_point of int_points) {\r\n            if (int_point.edge_before === undefined || int_point.edge_after === undefined)  // completely deleted\r\n                continue;\r\n            if (int_point.face)            // already restored\r\n                continue;\r\n\r\n            if (int_point.edge_after.face || int_point.edge_before.face)        // Face already created. Possible case in duplicated intersection points\r\n                continue;\r\n\r\n            let first = int_point.edge_after;      // face start\r\n            let last = int_point.edge_before;      // face end;\r\n\r\n            let face = polygon.addFace(first, last);\r\n\r\n            // Mark intersection points from the newly create face\r\n            // to avoid multiple creation of the same face\r\n            // Face was assigned to each edge of new face in addFace function\r\n            for (let int_point_tmp of int_points) {\r\n                if (int_point_tmp.edge_before && int_point_tmp.edge_after &&\r\n                    int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {\r\n                    int_point_tmp.face = face;\r\n                }\r\n            }\r\n            // Mark other intersection points as well\r\n            for (let int_point_tmp of other_int_points) {\r\n                if (int_point_tmp.edge_before && int_point_tmp.edge_after &&\r\n                    int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {\r\n                    int_point_tmp.face = face;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    static removeNotRelevantNotIntersectedFaces(polygon, notIntersectedFaces, op, is_res_polygon) {\r\n        for (let face of notIntersectedFaces) {\r\n            let rel = face.first.bv;\r\n            if (op === BooleanOp.BOOLEAN_UNION && rel === Flatten.INSIDE ||\r\n                op === BooleanOp.BOOLEAN_SUBTRACT && rel === Flatten.INSIDE && is_res_polygon ||\r\n                op === BooleanOp.BOOLEAN_SUBTRACT && rel === Flatten.OUTSIDE && !is_res_polygon ||\r\n                op === BooleanOp.BOOLEAN_INTERSECT && rel === Flatten.OUTSIDE) {\r\n\r\n                polygon.deleteFace(face);\r\n            }\r\n        }\r\n    }\r\n\r\n    static mergeRelevantNotIntersectedFaces(res_polygon, wrk_polygon) {\r\n        // All not relevant faces should be already deleted from wrk_polygon\r\n        for (let face of wrk_polygon.faces) {\r\n            res_polygon.addFace(face);\r\n        }\r\n    }\r\n\r\n};\r\n\r\nBooleanOp.BOOLEAN_UNION = 1;\r\nBooleanOp.BOOLEAN_INTERSECT = 2;\r\nBooleanOp.BOOLEAN_SUBTRACT = 3;\r\n\r\nBooleanOp.Flatten = Flatten;\r\n\r\nmodule.exports = BooleanOp;","/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n'use strict';\r\n\r\nlet Utils = require(\"./utils/utils\");\r\nlet Errors = require(\"./utils/errors\");\r\n\r\n/**\r\n * FlattenJS - library for 2d geometry\r\n * @type {Flatten}\r\n */\r\nlet Flatten = class Flatten {\r\n    constructor() {\r\n        this.DP_TOL = Utils.DP_TOL;\r\n        this.CCW = true;\r\n        this.CW = false;\r\n        this.ORIENTATION = {CCW:-1, CW:1, NOT_ORIENTABLE: 0};\r\n        this.PIx2 = 2 * Math.PI;\r\n        // this.PI_2 = 0.5 * Math.PI;\r\n        this.INSIDE = 1;\r\n        this.OUTSIDE = 0;\r\n        this.BOUNDARY = 2;\r\n        this.CONTAINS = 3;\r\n        this.INTERLACE = 4;\r\n        this.OVERLAP_SAME = 1;\r\n        this.OVERLAP_OPPOSITE = 2;\r\n        this.Utils = Utils;\r\n        this.Errors = Errors;\r\n    }\r\n};\r\n\r\nlet f = new Flatten();\r\n\r\nrequire(\"./classes/matrix\")(f);\r\nrequire(\"./data_structures/planar_set\")(f);\r\nrequire(\"./classes/point\")(f);\r\nrequire(\"./classes/vector\")(f);\r\nrequire(\"./classes/line\")(f);\r\nrequire(\"./classes/circle\")(f);\r\nrequire(\"./classes/segment\")(f);\r\nrequire(\"./classes/arc\")(f);\r\nrequire(\"./classes/box\")(f);\r\nrequire(\"./classes/edge\")(f);\r\nrequire(\"./classes/face\")(f);\r\nrequire(\"./classes/ray\")(f);\r\nrequire(\"./algorithms/ray_shooting\")(f);\r\nrequire(\"./classes/polygon\")(f);\r\nrequire(\"./algorithms/distance\")(f);\r\n\r\nmodule.exports = f;\r\n","/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n\r\n/**\r\n * Global constant DP_TOL is used for comparison of floating point numbers.\r\n * It is set to 0.000001.\r\n * @type {number}\r\n */\r\nconst DP_TOL = 0.000001;\r\nconst DECIMALS = 3;\r\n\r\nmodule.exports = {\r\n    DP_TOL: DP_TOL,\r\n    /**\r\n     * Returns *true* if value comparable to zero\r\n     * @return {boolean}\r\n     */\r\n    EQ_0: function(x) {\r\n        return ( (x) < DP_TOL && (x) > -DP_TOL );\r\n    },\r\n    /**\r\n     * Returns *true* if two values are equal up to DP_TOL\r\n     * @return {boolean}\r\n     */\r\n    EQ: function(x,y) {\r\n        return ( (x)-(y) <  DP_TOL && (x)-(y) > -DP_TOL );\r\n    },\r\n    /**\r\n     * Returns *true* if first argument greater than second argument up to DP_TOL\r\n     * @return {boolean}\r\n     */\r\n    GT: (x,y) => {\r\n        return ( (x)-(y) >  DP_TOL );\r\n    },\r\n    /**\r\n     * Returns *true* if first argument greater than or equal to second argument up to DP_TOL\r\n     * @return {boolean}\r\n     */\r\n    GE: (x,y) => {\r\n        return ( (x)-(y) > -DP_TOL );\r\n    },\r\n    /**\r\n     * Returns *true* if first argument less than second argument up to DP_TOL\r\n     * @return {boolean}\r\n     */\r\n    LT: (x,y) => {\r\n        return ( (x)-(y) < -DP_TOL )\r\n    },\r\n    /**\r\n     * Returns *true* if first argument less than or equal to second argument up to DP_TOL\r\n     * @return {boolean}\r\n     */\r\n    LE: (x,y) => {\r\n        return ( (x)-(y) <  DP_TOL );\r\n    }\r\n};\r\n","/**\r\n * Created by Alex Bol on 2/19/2017.\r\n */\r\nmodule.exports = {\r\n    ILLEGAL_PARAMETERS: new ReferenceError('Illegal Parameters'),\r\n    ZERO_DIVISION: new Error('Zero division')\r\n};\r\n\r\n","\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class representing an affine transformation 3x3 matrix:\r\n     * <pre>\r\n     *      [ a  c  tx\r\n     * A =    b  d  ty\r\n     *        0  0  1  ]\r\n     * </pre\r\n     * @type {Matrix}\r\n     */\r\n    Flatten.Matrix = class Matrix {\r\n        /**\r\n         * Construct new instance of affine transformation matrix <br/>\r\n         * If parameters omitted, construct identity matrix a = 1, d = 1\r\n         * @param {number} a - position(0,0)   sx*cos(alpha)\r\n         * @param {number} b - position (0,1)  sx*sin(alpha)\r\n         * @param {number} c - position (1,0)  -sy*sin(alpha)\r\n         * @param {number} d - position (1,1)  sy*cos(alpha)\r\n         * @param {number} tx - position (2,0) translation by x\r\n         * @param {number} ty - position (2,1) translation by y\r\n         */\r\n        constructor(a=1,b=0,c=0,d=1,tx=0,ty=0) {\r\n            this.a = a;\r\n            this.b = b;\r\n            this.c = c;\r\n            this.d = d;\r\n            this.tx = tx;\r\n            this.ty = ty;\r\n        }\r\n\r\n        /**\r\n         * Returns a clone of the Matrix instance.\r\n         * @return {Matrix}\r\n         **/\r\n        clone() {\r\n            return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);\r\n        };\r\n\r\n        /**\r\n         * Transform vector [x,y] using transformation matrix. <br/>\r\n         * Vector [x,y] is an abstract array[2] of numbers and not a FlattenJS object <br/>\r\n         * The result is also an abstract vector [x',y'] = A * [x,y]:\r\n         * <code>\r\n         * [x'       [ ax + by + tx\r\n         *  y'   =     cx + dy + ty\r\n         *  1]                    1 ]\r\n         * </code>\r\n         * @param {number[]} vector - array[2] of numbers\r\n         * @returns {number[]} transformation result - array[2] of numbers\r\n         */\r\n        transform(vector) {\r\n            return [\r\n                vector[0]*this.a+vector[1]*this.c+this.tx,\r\n                vector[0]*this.b+vector[1]*this.d+this.ty\r\n            ]\r\n        };\r\n\r\n        /**\r\n         * Returns result of multiplication of this matrix by other matrix\r\n         * @param {Matrix} other_matrix - matrix to multiply by\r\n         * @returns {Matrix}\r\n         */\r\n        multiply(other_matrix) {\r\n            return new Matrix(\r\n                this.a*other_matrix.a + this.c*other_matrix.b,\r\n                this.b*other_matrix.a + this.d*other_matrix.b,\r\n                this.a*other_matrix.c + this.c*other_matrix.d,\r\n                this.b*other_matrix.c + this.d*other_matrix.d,\r\n                this.a*other_matrix.tx + this.c*other_matrix.ty + this.tx,\r\n                this.b*other_matrix.tx + this.d*other_matrix.ty + this.ty\r\n            )\r\n        };\r\n\r\n        /**\r\n         * Return new matrix as a result of multiplication of the current matrix\r\n         * by the matrix(1,0,0,1,tx,ty)\r\n         * @param {number} tx - translation by x\r\n         * @param {number} ty - translation by y\r\n         * @returns {Matrix}\r\n         */\r\n        translate(...args) {\r\n            let tx, ty;\r\n            if (args.length == 1 && (args[0] instanceof Flatten.Vector)) {\r\n                tx = args[0].x;\r\n                ty = args[0].y;\r\n            }\r\n            else if (args.length == 2 && typeof(args[0]) == \"number\" && typeof(args[1]) == \"number\") {\r\n                tx = args[0];\r\n                ty = args[1];\r\n            }\r\n            else {\r\n                throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n            }\r\n            return this.multiply(new Matrix(1,0,0,1,tx,ty))\r\n        };\r\n\r\n        /**\r\n         * Return new matrix as a result of multiplication of the current matrix\r\n         * by the matrix that defines rotation by given angle (in radians) around\r\n         * point (0,0) in counter clockwise direction\r\n         * @param angle\r\n         * @returns {Matrix}\r\n         */\r\n        rotate(angle) {\r\n            let cos = Math.cos(angle);\r\n            let sin = Math.sin(angle);\r\n            return this.multiply(new Matrix(cos,sin,-sin,cos,0,0));\r\n        };\r\n\r\n        /**\r\n         * Return new matrix as a result of multiplication of the current matrix\r\n         * by the matrix (sx,0,0,sy,0,0) that defines scaling\r\n         * @param sx\r\n         * @param sy\r\n         * @returns {Matrix}\r\n         */\r\n        scale(sx, sy) {\r\n            return this.multiply(new Matrix(sx,0,0,sy,0,0));\r\n        };\r\n\r\n        /**\r\n         * Returns true if two matrix are equal parameter by parameter\r\n         * @param {Matrix} matrix - other matrix\r\n         * @returns {boolean} true if equal, false otherwise\r\n         */\r\n        equalTo(matrix) {\r\n            if (!Flatten.Utils.EQ(this.tx, matrix.tx)) return false;\r\n            if (!Flatten.Utils.EQ(this.ty, matrix.ty)) return false;\r\n            if (!Flatten.Utils.EQ(this.a, matrix.a)) return false;\r\n            if (!Flatten.Utils.EQ(this.b, matrix.b)) return false;\r\n            if (!Flatten.Utils.EQ(this.c, matrix.c)) return false;\r\n            if (!Flatten.Utils.EQ(this.d, matrix.d)) return false;\r\n            return true;\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Function to create matrix equivalent to \"new\" constructor\r\n     * @param args\r\n     */\r\n    Flatten.matrix = (...args) => new Flatten.Matrix(...args);\r\n};\r\n","/**\r\n * Created by Alex Bol on 3/12/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\n// require(\"babel-polyfill\");\r\n\r\nlet IntervalTree = require('flatten-interval-tree');\r\n\r\nmodule.exports = function (Flatten) {\r\n    /**\r\n     * Class representing a planar set - a generic container with ability to keep and retrieve shapes and\r\n     * perform spatial queries. Planar set is an extension of Set container, so it supports\r\n     * Set properties and methods\r\n     */\r\n    Flatten.PlanarSet = class PlanarSet extends Set {\r\n        /**\r\n         * Create new empty instance of PlanarSet\r\n         */\r\n        constructor() {\r\n            super();\r\n            this.index = new IntervalTree();\r\n        }\r\n\r\n        /**\r\n         * Add new shape to planar set and to its spatial index.<br/>\r\n         * If shape already exist, it will not be added again.\r\n         * This happens with no error, it is possible to use <i>size</i> property to check if\r\n         * a shape was actually added.<br/>\r\n         * Method returns planar set object updated and may be chained\r\n         * @param {Shape} shape - shape to be added, should have valid <i>box</i> property\r\n         * @returns {PlanarSet}\r\n         */\r\n        add(shape) {\r\n            let size = this.size;\r\n            super.add(shape);\r\n            // size not changed - item not added, probably trying to add same item twice\r\n            if (this.size > size) {\r\n                let node = this.index.insert(shape.box, shape);\r\n            }\r\n            return this;         // in accordance to Set.add interface\r\n        }\r\n\r\n        /**\r\n         * Delete shape from planar set. Returns true if shape was actually deleted, false otherwise\r\n         * @param {Shape} shape - shape to be deleted\r\n         * @returns {boolean}\r\n         */\r\n        delete(shape) {\r\n            let deleted = super.delete(shape);\r\n            if (deleted) {\r\n                this.index.remove(shape.box, shape);\r\n            }\r\n            return deleted;\r\n        }\r\n\r\n        /**\r\n         * Clear planar set\r\n         */\r\n        clear() {\r\n            super.clear();\r\n            this.index = new IntervalTree();\r\n        }\r\n\r\n        /**\r\n         * 2d range search in planar set.<br/>\r\n         * Returns array of all shapes in planar set which bounding box is intersected with query box\r\n         * @param {Box} box - query box\r\n         * @returns {Shapes[]}\r\n         */\r\n        search(box) {\r\n            let resp = this.index.search(box);\r\n            return resp;\r\n        }\r\n\r\n        /**\r\n         * Point location test. Returns array of shapes which contains given point\r\n         * @param {Point} point - query point\r\n         * @returns {Array}\r\n         */\r\n        hit(point) {\r\n            let box = new Flatten.Box(point.x - 1, point.y - 1, point.x + 1, point.y + 1);\r\n            let resp = this.index.search(box);\r\n            return resp.filter((shape) => point.on(shape));\r\n        }\r\n\r\n        /**\r\n         * Returns svg string to draw all shapes in planar set\r\n         * @returns {String}\r\n         */\r\n        svg() {\r\n            let svgcontent = [...this].reduce((acc, shape) => acc + shape.svg(), \"\");\r\n            return svgcontent;\r\n        }\r\n    }\r\n};\r\n\r\n","/**\r\n * Created by Alex Bol on 4/1/2017.\r\n */\r\n\r\n'use strict';\r\n\r\n// let defaultTraits = require('../utils/numeric_traits');\r\nlet Interval = require('../classes/interval');\r\nlet {RB_TREE_COLOR_RED, RB_TREE_COLOR_BLACK} = require('../utils/constants');\r\n\r\nlet Node = class Node {\r\n    constructor(key = undefined, value = undefined,\r\n                left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {\r\n        this.left = left;                     // reference to left child node\r\n        this.right = right;                   // reference to right child node\r\n        this.parent = parent;                 // reference to parent node\r\n        this.color = color;\r\n\r\n        this.item = {key: key, value: value};   // key is supposed to be       instance of Interval\r\n\r\n        /* If not, this should by an array of two numbers */\r\n        if (key && key instanceof Array && key.length == 2) {\r\n            if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {\r\n                this.item.key = new Interval(Math.min(key[0], key[1]), Math.max(key[0], key[1]));\r\n            }\r\n        }\r\n        this.max = this.item.key ? this.item.key.max : undefined;\r\n    }\r\n\r\n    isNil() {\r\n        return (this.item.key === undefined && this.item.value === undefined &&\r\n            this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK);\r\n    }\r\n\r\n    less_than(other_node) {\r\n        return this.item.key.less_than(other_node.item.key);\r\n    }\r\n\r\n    equal_to(other_node) {\r\n        let value_equal = true;\r\n        if (this.item.value && other_node.item.value) {\r\n            value_equal = this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) :\r\n                this.item.value == other_node.item.value;\r\n        }\r\n        return this.item.key.equal_to(other_node.item.key) && value_equal;\r\n    }\r\n\r\n    intersect(other_node) {\r\n        return this.item.key.intersect(other_node.item.key);\r\n    }\r\n\r\n    copy_data(other_node) {\r\n        this.item.key = other_node.item.key.clone();\r\n        this.item.value = other_node.item.value;\r\n    }\r\n\r\n    update_max() {\r\n        // use key (Interval) max property instead of key.high\r\n        this.max = this.item.key ? this.item.key.max : undefined;\r\n        if (this.right && this.right.max) {\r\n            let maximal_val = this.item.key.maximal_val;\r\n            this.max = maximal_val(this.max, this.right.max);\r\n        }\r\n        if (this.left && this.left.max) {\r\n            let maximal_val = this.item.key.maximal_val;\r\n            this.max = maximal_val(this.max, this.left.max);\r\n        }\r\n    }\r\n\r\n    // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low\r\n    not_intersect_left_subtree(search_node) {\r\n        let val_less_than = this.item.key.val_less_than;\r\n        let high = this.left.max.high ? this.left.max.high : this.left.max;\r\n        return val_less_than(high, search_node.item.key.low);\r\n    }\r\n\r\n    // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low\r\n    not_intersect_right_subtree(search_node) {\r\n        let val_less_than = this.item.key.val_less_than;\r\n        let low = this.right.max.low ? this.right.max.low : this.right.item.key.low;\r\n        return val_less_than(search_node.item.key.high, low);\r\n    }\r\n};\r\n\r\nmodule.exports = Node;\r\n\r\n","/**\r\n * Created by Alex Bol on 4/1/2017.\r\n */\r\n\r\nlet Interval = class Interval {\r\n    constructor(low, high) {\r\n        this.low = low;\r\n        this.high = high;\r\n    }\r\n\r\n    get max() {\r\n        return this.high;\r\n    }\r\n\r\n    interval(low, high) {\r\n        return new Interval(low, high);\r\n    }\r\n\r\n    clone() {\r\n        return new Interval(this.low, this.high);\r\n    }\r\n\r\n    less_than(other_interval) {\r\n        return this.low < other_interval.low ||\r\n            this.low == other_interval.low && this.high < other_interval.high;\r\n    }\r\n\r\n    equal_to(other_interval) {\r\n        return this.low == other_interval.low && this.high == other_interval.high;\r\n    }\r\n\r\n    intersect(other_interval) {\r\n        return !this.not_intersect(other_interval);\r\n    }\r\n\r\n    not_intersect(other_interval) {\r\n        return (this.high < other_interval.low || other_interval.high < this.low);\r\n    }\r\n\r\n    output() {\r\n        return [this.low, this.high];\r\n    }\r\n\r\n    maximal_val(val1, val2) {\r\n        return Math.max(val1, val2);\r\n    }\r\n\r\n    val_less_than(val1, val2 ) {     // trait to compare max property with item ?\r\n        return val1 < val2;\r\n    }\r\n};\r\n\r\nmodule.exports = Interval;","/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n\r\n/**\r\n *\r\n * @param Flatten\r\n */\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     *\r\n     * Class representing a point\r\n     * @type {Point}\r\n     */\r\n    Flatten.Point = class Point {\r\n        /**\r\n         * Point may be constructed by two numbers, or by array of two numbers\r\n         * @param {number} x - x-coordinate (float number)\r\n         * @param {number} y - y-coordinate (float number)\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * x-coordinate (float number)\r\n             * @type {number}\r\n             */\r\n            this.x = 0;\r\n            /**\r\n             * y-coordinate (float number)\r\n             * @type {number}\r\n             */\r\n            this.y = 0;\r\n\r\n            if (args.length === 0) {\r\n                return;\r\n            }\r\n\r\n            if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\r\n                let arr = args[0];\r\n                if (typeof(arr[0]) == \"number\" && typeof(arr[1]) == \"number\") {\r\n                    this.x = arr[0];\r\n                    this.y = arr[1];\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (args.length === 1 && args[0] instanceof Object && args[0].name === \"point\") {\r\n                let {x, y} = args[0];\r\n                this.x = x;\r\n                this.y = y;\r\n                return;\r\n            }\r\n\r\n            if (args.length === 2) {\r\n                if (typeof(args[0]) == \"number\" && typeof(args[1]) == \"number\") {\r\n                    this.x = args[0];\r\n                    this.y = args[1];\r\n                    return;\r\n                }\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns bounding box of a point\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            return new Flatten.Box(this.x, this.y, this.x, this.y);\r\n        }\r\n\r\n        /**\r\n         * Method clone returns new copied instance of point\r\n         * @returns {Point}\r\n         */\r\n        clone() {\r\n            return new Flatten.Point(this.x, this.y);\r\n        }\r\n\r\n        get vertices() {\r\n            return [this.clone()];\r\n        }\r\n\r\n        /**\r\n         * Returns true if points are equal up to [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\r\n         * @param {Point} pt Query point\r\n         * @returns {boolean}\r\n         */\r\n        equalTo(pt) {\r\n            return Flatten.Utils.EQ(this.x, pt.x) && Flatten.Utils.EQ(this.y, pt.y);\r\n        }\r\n\r\n        /**\r\n         * Defines predicate \"less than\" between points. Returns true if the point is less than query points, false otherwise <br/>\r\n         * By definition point1 < point2 if {point1.y < point2.y || point1.y == point2.y && point1.x < point2.y <br/>\r\n         * Numeric values compared with [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\r\n         * @param {Point} pt Query point\r\n         * @returns {boolean}\r\n         */\r\n        lessThan(pt) {\r\n            if (Flatten.Utils.LT(this.y, pt.y))\r\n                return true;\r\n            if (Flatten.Utils.EQ(this.y, pt.y) && Flatten.Utils.LT(this.x, pt.x))\r\n                return true;\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Returns new point rotated by given angle around given center point.\r\n         * If center point is omitted, rotates around zero point (0,0).\r\n         * Positive value of angle defines rotation in counter clockwise direction,\r\n         * negative angle defines rotation in clockwise clockwise direction\r\n         * @param {number} angle - angle in radians\r\n         * @param {Point} [center=(0,0)] center\r\n         * @returns {Point}\r\n         */\r\n        rotate(angle, center = {x:0, y:0}) {\r\n            var x_rot = center.x + (this.x - center.x) * Math.cos(angle) - (this.y - center.y) * Math.sin(angle);\r\n            var y_rot = center.y + (this.x - center.x) * Math.sin(angle) + (this.y - center.y) * Math.cos(angle);\r\n\r\n            return new Flatten.Point(x_rot, y_rot);\r\n        }\r\n\r\n        /**\r\n         * Returns new point translated by given vector.\r\n         * Translation vector may by also defined by a pair of numbers.\r\n         * @param {Vector} vector - Translation vector defined as Flatten.Vector or\r\n         * @param {number|number} - Translation vector defined as pair of numbers\r\n         * @returns {Point}\r\n         */\r\n        translate(...args) {\r\n            if (args.length == 1 && (args[0] instanceof Flatten.Vector)) {\r\n                return new Flatten.Point(this.x + args[0].x, this.y + args[0].y);\r\n            }\r\n\r\n            if (args.length == 2 && typeof(args[0]) == \"number\" && typeof(args[1]) == \"number\") {\r\n                return new Flatten.Point(this.x + args[0], this.y + args[1]);\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Return new point transformed by affine transformation matrix m\r\n         * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\r\n         * @returns {Point}\r\n         */\r\n        transform(m) {\r\n            // let [x,y] = m.transform([this.x,this.y]);\r\n            return new Flatten.Point(m.transform([this.x,this.y]))\r\n        }\r\n\r\n        /**\r\n         * Returns projection point on given line\r\n         * @param {Line} line Line this point be projected on\r\n         * @returns {Point}\r\n         */\r\n        projectionOn(line) {\r\n            if (this.equalTo(line.pt))                   // this point equal to line anchor point\r\n                return this.clone();\r\n\r\n            let vec = new Flatten.Vector(this, line.pt);\r\n            if (Flatten.Utils.EQ_0(vec.cross(line.norm)))    // vector to point from anchor point collinear to normal vector\r\n                return line.pt.clone();\r\n\r\n            let dist = vec.dot(line.norm);             // signed distance\r\n            let proj_vec = line.norm.multiply(dist);\r\n            return this.translate(proj_vec);\r\n        }\r\n\r\n        /**\r\n         * Returns true if point belongs to the \"left\" semi-plane, which means, point belongs to the same semi plane where line normal vector points to\r\n         * Return false if point belongs to the \"right\" semi-plane or to the line itself\r\n         * @param {Line} line Query line\r\n         * @returns {boolean}\r\n         */\r\n        leftTo(line) {\r\n            let vec = new Flatten.Vector(line.pt, this);\r\n            let onLeftSemiPlane = Flatten.Utils.GT(vec.dot(line.norm), 0);\r\n            return onLeftSemiPlane;\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment from point to shape and return as array [distance, shortest segment]\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n         * @returns {number} distance from point to shape\r\n         * @returns {Segment} shortest segment between point and shape (started at point, ended at shape)\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n\r\n            if (shape instanceof Point) {\r\n                let dx = shape.x - this.x;\r\n                let dy = shape.y - this.y;\r\n                return [Math.sqrt(dx*dx + dy*dy), new Flatten.Segment(this, shape)];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                return Distance.point2line(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                return Distance.point2circle(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                return Distance.point2segment(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                // let [dist, ...rest] = Distance.point2arc(this, shape);\r\n                // return dist;\r\n                return Distance.point2arc(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                // let [dist, ...rest] = Distance.point2polygon(this, shape);\r\n                // return dist;\r\n                return Distance.point2polygon(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.PlanarSet) {\r\n                return Distance.shape2planarSet(this, shape);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns true if point is on a shape, false otherwise\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon\r\n         * @returns {boolean}\r\n         */\r\n        on(shape) {\r\n            if (shape instanceof Flatten.Point) {\r\n                return this.equalTo(shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                return shape.contains(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                return shape.contains(this);\r\n            }\r\n\r\n            if (shape instanceof  Flatten.Segment) {\r\n                return shape.contains(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                return shape.contains(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                return shape.contains(this);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Return string to draw point in svg as circle with radius \"r\" <br/>\r\n         * Accept any valid attributes of svg elements as svg object\r\n         * Defaults attribues are: <br/>\r\n         * {\r\n         *    r:\"3\",\r\n         *    stroke:\"black\",\r\n         *    strokeWidth:\"1\",\r\n         *    fill:\"red\"\r\n         * }\r\n         * @param {Object} attrs - Any valid attributes of svg circle element, like \"r\", \"stroke\", \"strokeWidth\", \"fill\"\r\n         * @returns {String}\r\n         */\r\n        svg(attrs = {}) {\r\n            let {r, stroke, strokeWidth, fill, id, className} = attrs;\r\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n            return `\\n<circle cx=\"${this.x}\" cy=\"${this.y}\" r=\"${r || 3}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"red\"}\" ${id_str} ${class_str} />`;\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return Object.assign({},this,{name:\"point\"});\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Function to create point equivalent to \"new\" constructor\r\n     * @param args\r\n     */\r\n    Flatten.point = (...args) => new Flatten.Point(...args);\r\n};\r\n","/**\r\n * Created by Alex Bol on 2/19/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class representing a vector\r\n     * @type {Vector}\r\n     */\r\n    Flatten.Vector = class Vector {\r\n        /**\r\n         * Vector may be constructed by two points, or by two float numbers,\r\n         * or by array of two numbers\r\n         * @param {Point} ps - start point\r\n         * @param {Point} pe - end point\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * x-coordinate of a vector (float number)\r\n             * @type {number}\r\n             */\r\n            this.x = 0;\r\n            /**\r\n             * y-coordinate of a vector (float number)\r\n             * @type {number}\r\n             */\r\n            this.y = 0;\r\n\r\n            /* return zero vector */\r\n            if (args.length === 0) {\r\n                return;\r\n            }\r\n\r\n            if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\r\n                let arr = args[0];\r\n                if (typeof(arr[0]) == \"number\" && typeof(arr[1]) == \"number\") {\r\n                    this.x = arr[0];\r\n                    this.y = arr[1];\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (args.length === 1 && args[0] instanceof Object && args[0].name === \"vector\") {\r\n                let {x, y} = args[0];\r\n                this.x = x;\r\n                this.y = y;\r\n                return;\r\n            }\r\n\r\n            if (args.length === 2) {\r\n                let a1 = args[0];\r\n                let a2 = args[1];\r\n\r\n                if (typeof(a1) == \"number\" && typeof(a2) == \"number\") {\r\n                    this.x = a1;\r\n                    this.y = a2;\r\n                    return;\r\n                }\r\n\r\n                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\r\n                    this.x = a2.x - a1.x;\r\n                    this.y = a2.y - a1.y;\r\n                    return;\r\n                }\r\n\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Method clone returns new instance of Vector\r\n         * @returns {Vector}\r\n         */\r\n        clone() {\r\n            return new Vector(this.x, this.y);\r\n        }\r\n\r\n        /**\r\n         * Slope of the vector in radians from 0 to 2PI\r\n         * @returns {number}\r\n         */\r\n        get slope() {\r\n            let angle = Math.atan2(this.y, this.x);\r\n            if (angle<0) angle = 2*Math.PI + angle;\r\n            return angle;\r\n        }\r\n\r\n        /**\r\n         * Length of vector\r\n         * @returns {number}\r\n         */\r\n        get length() {\r\n            return Math.sqrt(this.dot(this));\r\n        }\r\n\r\n        /**\r\n         * Returns true if vectors are equal up to [DP_TOL]{@link http://localhost:63342/flatten-js/docs/global.html#DP_TOL}\r\n         * tolerance\r\n         * @param {Vector} v\r\n         * @returns {boolean}\r\n         */\r\n        equalTo(v) {\r\n            return Flatten.Utils.EQ(this.x, v.x) && Flatten.Utils.EQ(this.y, v.y);\r\n        }\r\n\r\n        /**\r\n         * Returns new vector multiplied by scalar\r\n         * @param {number} scalar\r\n         * @returns {Vector}\r\n         */\r\n        multiply(scalar) {\r\n            return ( new Vector(scalar * this.x, scalar * this.y) );\r\n        }\r\n\r\n        /**\r\n         * Returns scalar product (dot product) of two vectors <br/>\r\n         * <code>dot_product = (this * v)</code>\r\n         * @param {Vector} v Other vector\r\n         * @returns {number}\r\n         */\r\n        dot(v) {\r\n            return ( this.x * v.x + this.y * v.y );\r\n        }\r\n\r\n        /**\r\n         * Returns vector product (cross product) of two vectors <br/>\r\n         * <code>cross_product = (this x v)</code>\r\n         * @param {Vector} v Other vector\r\n         * @returns {number}\r\n         */\r\n        cross(v) {\r\n            return ( this.x * v.y - this.y * v.x );\r\n        }\r\n\r\n        /**\r\n         * Returns unit vector.<br/>\r\n         * Throw error if given vector has zero length\r\n         * @returns {Vector}\r\n         */\r\n        normalize() {\r\n            if (!Flatten.Utils.EQ_0(this.length)) {\r\n                return ( new Vector(this.x / this.length, this.y / this.length) );\r\n            }\r\n            throw Flatten.Errors.ZERO_DIVISION;\r\n        }\r\n\r\n        /**\r\n         * Returns new vector rotated by given angle,\r\n         * positive angle defines rotation in counter clockwise direction,\r\n         * negative - in clockwise direction\r\n         * @param {number} angle - Angle in radians\r\n         * @returns {Vector}\r\n         */\r\n        rotate(angle) {\r\n            let point = new Flatten.Point(this.x, this.y);\r\n            let rpoint = point.rotate(angle);\r\n            return new Flatten.Vector(rpoint.x, rpoint.y);\r\n        }\r\n\r\n        /**\r\n         * Returns vector rotated 90 degrees counter clockwise\r\n         * @returns {Vector}\r\n         */\r\n        rotate90CCW() {\r\n            return new Flatten.Vector(-this.y, this.x);\r\n        };\r\n\r\n        /**\r\n         * Returns vector rotated 90 degrees clockwise\r\n         * @returns {Vector}\r\n         */\r\n        rotate90CW() {\r\n            return new Flatten.Vector(this.y, -this.x);\r\n        };\r\n\r\n        /**\r\n         * Return inverted vector\r\n         * @returns {Vector}\r\n         */\r\n        invert() {\r\n            return new Flatten.Vector(-this.x, -this.y);\r\n        }\r\n\r\n        /**\r\n         * Return result of addition of other vector to this vector as a new vector\r\n         * @param {Vector} v Other vector\r\n         * @returns {Vector}\r\n         */\r\n        add(v) {\r\n            return new Flatten.Vector(this.x + v.x, this.y + v.y);\r\n        }\r\n\r\n        /**\r\n         * Return result of subtraction of other vector from current vector as a new vector\r\n         * @param {Vector} v Another vector\r\n         * @returns {Vector}\r\n         */\r\n        subtract(v) {\r\n            return new Flatten.Vector(this.x - v.x, this.y - v.y);\r\n        }\r\n\r\n        /**\r\n         * Return angle between this vector and other vector. <br/>\r\n         * Angle is measured from 0 to 2*PI in the counter clockwise direction\r\n         * from current vector to other.\r\n         * @param {Vector} v Another vector\r\n         * @returns {number}\r\n         */\r\n        angleTo(v) {\r\n            let norm1 = this.normalize();\r\n            let norm2 = v.normalize();\r\n            let angle = Math.atan2(norm1.cross(norm2), norm1.dot(norm2));\r\n            if (angle<0) angle += 2*Math.PI;\r\n            return angle;\r\n        }\r\n\r\n        /**\r\n         * Return vector projection of the current vector on another vector\r\n         * @param {Vector} v Another vector\r\n         * @returns {Vector}\r\n         */\r\n        projectionOn(v){\r\n            let n = v.normalize();\r\n            let d = this.dot(n);\r\n            return n.multiply(d);\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return Object.assign({},this,{name:\"vector\"});\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Function to create vector equivalent to \"new\" constructor\r\n     * @param args\r\n     */\r\n    Flatten.vector = (...args) => new Flatten.Vector(...args);\r\n};\r\n","/**\r\n * Created by Alex Bol on 2/20/2017.\r\n */\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class representing a line\r\n     * @type {Line}\r\n     */\r\n    Flatten.Line = class Line {\r\n        /**\r\n         * Line may be constructed by point and normal vector or by two points that a line passes through\r\n         * @param {Point} pt - point that a line passes through\r\n         * @param {Vector|Point} norm - normal vector to a line or second point a line passes through\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * Point a line passes through\r\n             * @type {Point}\r\n             */\r\n            this.pt = new Flatten.Point();\r\n            /**\r\n             * Normal vector to a line <br/>\r\n             * Vector is normalized (length == 1)\r\n             * @type {Vector}\r\n             */\r\n            this.norm = new Flatten.Vector(0,1);\r\n\r\n            if (args.length == 0) {\r\n                return;\r\n            }\r\n\r\n            if (args.length == 1 && args[0] instanceof Object && args[0].name === \"line\") {\r\n                let {pt, norm} = args[0];\r\n                this.pt = new Flatten.Point(pt);\r\n                this.norm = new Flatten.Vector(norm);\r\n                return;\r\n            }\r\n\r\n            if (args.length == 2) {\r\n                let a1 = args[0];\r\n                let a2 = args[1];\r\n\r\n                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\r\n                    this.pt = a1;\r\n                    this.norm = Line.points2norm(a1, a2);\r\n                    return;\r\n                }\r\n\r\n                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Vector) {\r\n                    if (Flatten.Utils.EQ_0(a2.x) && Flatten.Utils.EQ_0(a2.y)) {\r\n                        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n                    }\r\n                    this.pt = a1.clone();\r\n                    this.norm = a2.clone();\r\n                    this.norm = this.norm.normalize();\r\n                    return;\r\n                }\r\n\r\n                if (a1 instanceof Flatten.Vector && a2 instanceof Flatten.Point) {\r\n                    if (Flatten.Utils.EQ_0(a1.x) && Flatten.Utils.EQ_0(a1.y)) {\r\n                        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n                    }\r\n                    this.pt = a2.clone();\r\n                    this.norm = a1.clone();\r\n                    this.norm = this.norm.normalize();\r\n                    return;\r\n                }\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Returns cloned new instance of a line\r\n         * @returns {Line}\r\n         */\r\n        clone() {\r\n            return new Flatten.Line(this.pt, this.norm);\r\n        }\r\n\r\n        /**\r\n         * Slope of the line - angle in radians between line and axe x from 0 to 2PI\r\n         * @returns {number} - slope of the line\r\n         */\r\n        get slope() {\r\n            let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\r\n            return vec.slope;\r\n        }\r\n\r\n        /**\r\n         * Get coefficients [A,B,C] of a standard line equation in the form Ax + By = C\r\n         * @code [A, B, C] = line.standard\r\n         * @returns {number[]} - array of coefficients\r\n         */\r\n        get standard() {\r\n            let A = this.norm.x;\r\n            let B = this.norm.y;\r\n            let C = this.norm.dot(this.pt);\r\n\r\n            return [A,B,C];\r\n        }\r\n\r\n        /**\r\n         * Return true if parallel or incident to other line\r\n         * @param {Line} other_line - line to check\r\n         * @returns {boolean}\r\n         */\r\n        parallelTo(other_line) {\r\n            return Flatten.Utils.EQ_0(this.norm.cross(other_line.norm));\r\n        }\r\n\r\n        /**\r\n         * Returns true if incident to other line\r\n         * @param {Line} other_line - line to check\r\n         * @returns {boolean}\r\n         */\r\n        incidentTo(other_line) {\r\n            return this.parallelTo(other_line) && this.pt.on(other_line);\r\n        }\r\n\r\n        /**\r\n         * Returns true if point belongs to line\r\n         * @param {Point} pt Query point\r\n         * @returns {boolean}\r\n         */\r\n        contains(pt) {\r\n            if (this.pt.equalTo(pt)) {\r\n                return true;\r\n            }\r\n            /* Line contains point if vector to point is orthogonal to the line normal vector */\r\n            let vec = new Flatten.Vector(this.pt, pt);\r\n            return Flatten.Utils.EQ_0(this.norm.dot(vec));\r\n        }\r\n\r\n        /**\r\n         * Returns array of intersection points\r\n         * @param {Shape} shape - shape to intersect with\r\n         * @returns {Point[]}\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Flatten.Point) {\r\n                return this.contains(shape) ? [shape] : [];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                return Line.intersectLine2Line(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                return Line.intersectLine2Circle(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                return shape.intersect(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                return Line.intersectLine2Arc(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                return Flatten.Polygon.intersectLine2Polygon(this, shape);\r\n            }\r\n\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment from line to shape and returns array [distance, shortest_segment]\r\n         * @param {Shape} shape Shape of the one of the types Point, Circle, Segment, Arc, Polygon\r\n         * @returns {Number}\r\n         * @returns {Segment}\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n\r\n            if (shape instanceof Flatten.Point) {\r\n                let [distance, shortest_segment] = Distance.point2line(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                let [distance, shortest_segment] = Distance.circle2line(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                let [distance, shortest_segment] = Distance.segment2line(shape, this);\r\n                return [distance, shortest_segment.reverse()];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                let [distance, shortest_segment] = Distance.arc2line(shape, this);\r\n                return [distance, shortest_segment.reverse()];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                let [distance, shortest_segment] = Distance.shape2polygon(this, shape);\r\n                return [distance, shortest_segment];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Return string to draw svg segment representing line inside given box\r\n         * @param {Box} box Box representing drawing area\r\n         * @param {Object} attrs - an object with attributes of svg circle element\r\n         */\r\n        svg(box, attrs = {}) {\r\n            let ip = Line.intersectLine2Box(this, box);\r\n            if (ip.length === 0)\r\n                return \"\";\r\n            let ps = ip[0];\r\n            let pe = ip.length == 2 ? ip[1] : ip.find( pt => !pt.equalTo(ps) );\r\n            if (pe === undefined) pe = ps;\r\n            let segment = new Flatten.Segment(ps, pe);\r\n            return segment.svg(attrs);\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return Object.assign({},this,{name:\"line\"});\r\n        }\r\n\r\n        static points2norm(pt1, pt2) {\r\n            if (pt1.equalTo(pt2)) {\r\n                throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n            }\r\n            let vec = new Flatten.Vector(pt1, pt2);\r\n            let unit = vec.normalize();\r\n            return unit.rotate90CCW();\r\n        }\r\n\r\n        static intersectLine2Line(line1, line2) {\r\n            let ip = [];\r\n\r\n            let [A1, B1, C1] = line1.standard;\r\n            let [A2, B2, C2] = line2.standard;\r\n\r\n            /* Cramer's rule */\r\n            let det = A1*B2 - B1*A2;\r\n            let detX = C1*B2 - B1*C2;\r\n            let detY = A1*C2 - C1*A2;\r\n\r\n            if (!Flatten.Utils.EQ_0(det)) {\r\n                let new_ip = new Flatten.Point( detX/det, detY/det );\r\n                ip.push(new_ip);\r\n            }\r\n            return ip;\r\n        }\r\n\r\n        static intersectLine2Circle(line, circle) {\r\n            let ip = [];\r\n            let prj = circle.pc.projectionOn(line);            // projection of circle center on line\r\n            let dist = circle.pc.distanceTo(prj)[0];           // distance from circle center to projection\r\n\r\n            if (Flatten.Utils.EQ(dist, circle.r)) {            // line tangent to circle - return single intersection point\r\n                ip.push(prj);\r\n            }\r\n            else if (Flatten.Utils.LT(dist, circle.r)) {       // return two intersection points\r\n                let delta = Math.sqrt(circle.r*circle.r - dist*dist);\r\n                let v_trans, pt;\r\n\r\n                v_trans = line.norm.rotate90CCW().multiply(delta);\r\n                pt = prj.translate(v_trans);\r\n                ip.push(pt);\r\n\r\n                v_trans = line.norm.rotate90CW().multiply(delta);\r\n                pt = prj.translate(v_trans);\r\n                ip.push(pt);\r\n            }\r\n            return ip;\r\n        }\r\n\r\n        static intersectLine2Box(line, box) {\r\n            let pts = [\r\n                new Flatten.Point(box.xmin, box.ymin),\r\n                new Flatten.Point(box.xmax, box.ymin),\r\n                new Flatten.Point(box.xmax, box.ymax),\r\n                new Flatten.Point(box.xmin, box.ymax)\r\n            ];\r\n            let segs = [\r\n                new Flatten.Segment(pts[0], pts[1]),\r\n                new Flatten.Segment(pts[1], pts[2]),\r\n                new Flatten.Segment(pts[2], pts[3]),\r\n                new Flatten.Segment(pts[3], pts[0])\r\n            ];\r\n\r\n            let ips =  [];\r\n\r\n            for(let seg of segs) {\r\n                let ips_tmp = seg.intersect(line);\r\n                for (let ip of ips_tmp) {\r\n                    ips.push(ip);\r\n                }\r\n            };\r\n            return ips;\r\n        }\r\n\r\n        static intersectLine2Arc(line, arc) {\r\n            let ip = [];\r\n\r\n            if (Line.intersectLine2Box(line, arc.box).length == 0) {\r\n                return ip;\r\n            }\r\n\r\n            let circle = new Flatten.Circle(arc.pc, arc.r);\r\n            let ip_tmp = line.intersect(circle);\r\n            for (let pt of ip_tmp) {\r\n                if (pt.on(arc)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n\r\n            return ip;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Function to create line equivalent to \"new\" constructor\r\n     * @param args\r\n     */\r\n    Flatten.line = (...args) => new Flatten.Line(...args);\r\n};\r\n","/**\r\n * Created by Alex Bol on 3/6/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    let {Arc,vector} = Flatten;\r\n    /**\r\n     * Class representing a circle\r\n     * @type {Circle}\r\n     */\r\n    Flatten.Circle = class Circle {\r\n        /**\r\n         *\r\n         * @param {Point} pc - circle center point\r\n         * @param {number} r - circle radius\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * Circle center\r\n             * @type {Point}\r\n             */\r\n            this.pc = new Flatten.Point();\r\n            /**\r\n             * Circle radius\r\n             * @type {number}\r\n             */\r\n            this.r = 1;\r\n\r\n            if (args.length == 1 && args[0] instanceof Object && args[0].name === \"circle\") {\r\n                let {pc, r} = args[0];\r\n                this.pc = new Flatten.Point(pc);\r\n                this.r = r;\r\n                return;\r\n            }\r\n            else {\r\n                let [pc, r] = [...args];\r\n                if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\r\n                if (r !== undefined) this.r = r;\r\n                return;\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Method clone returns new instance of a Circle\r\n         * @returns {Circle}\r\n         */\r\n        clone() {\r\n            return new Flatten.Circle(this.pc.clone(), this.r);\r\n        }\r\n\r\n        /**\r\n         * Circle center\r\n         * @returns {Point}\r\n         */\r\n        get center() {\r\n            return this.pc;\r\n        }\r\n\r\n        /**\r\n         * Circle bounding box\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            return new Flatten.Box(\r\n                this.pc.x - this.r,\r\n                this.pc.y - this.r,\r\n                this.pc.x + this.r,\r\n                this.pc.y + this.r\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Return true if circle contains point\r\n         * @param {Point} pt - test point\r\n         * @returns {boolean}\r\n         */\r\n        contains(pt) {\r\n            return Flatten.Utils.LE(pt.distanceTo(this.center)[0], this.r);\r\n        }\r\n\r\n        /**\r\n         * Transform circle to closed arc\r\n         * @param {boolean} counterclockwise\r\n         * @returns {Arc}\r\n         */\r\n        toArc(counterclockwise=true) {\r\n            return new Flatten.Arc(this.center, this.r, Math.PI, -Math.PI, counterclockwise);\r\n        }\r\n\r\n        /**\r\n         * Returns array of intersection points between circle and other shape\r\n         * @param {Shape} shape Shape of the one of supported types\r\n         * @returns {Point[]}\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Flatten.Point) {\r\n                return this.contains(shape) ? [shape] : [];\r\n            }\r\n            if (shape instanceof Flatten.Line) {\r\n                return shape.intersect(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                return shape.intersect(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                return Circle.intersectCirle2Circle(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                return shape.intersect(this);\r\n            }\r\n            if (shape instanceof Flatten.Polygon) {\r\n                return Flatten.Polygon.intersectShape2Polygon(this, shape);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment from circle to shape and return array [distance, shortest segment]\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n         * @returns {number} distance from circle to shape\r\n         * @returns {Segment} shortest segment between circle and shape (started at circle, ended at shape)\r\n\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n            let {point2circle, circle2circle, circle2line, segment2circle, arc2circle} = Distance;\r\n\r\n            if (shape instanceof Flatten.Point) {\r\n                let [distance, shortest_segment] = point2circle(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                let [distance, shortest_segment] = circle2circle(this, shape);\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                let [distance, shortest_segment] = circle2line(this, shape);\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                let [distance, shortest_segment] = segment2circle(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                let [distance, shortest_segment] = arc2circle(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                let [distance, shortest_segment] = Distance.shape2polygon(this, shape);\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.PlanarSet) {\r\n                let [dist, shortest_segment] = Distance.shape2planarSet(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n        }\r\n\r\n        static intersectCirle2Circle(circle1, circle2) {\r\n            let ip = [];\r\n\r\n            if (circle1.box.not_intersect(circle2.box)) {\r\n                return ip;\r\n            }\r\n\r\n            let vec = new Flatten.Vector(circle1.pc, circle2.pc);\r\n\r\n            let r1 = circle1.r;\r\n            let r2 = circle2.r;\r\n\r\n            // Degenerated circle\r\n            if (Flatten.Utils.EQ_0(r1) || Flatten.Utils.EQ_0(r2))\r\n                return ip;\r\n\r\n            // In case of equal circles return one leftmost point\r\n            if (Flatten.Utils.EQ_0(vec.x) && Flatten.Utils.EQ_0(vec.y) && Flatten.Utils.EQ(r1, r2)) {\r\n                ip.push(circle1.pc.translate(-r1, 0));\r\n                return ip;\r\n            }\r\n\r\n            let dist = circle1.pc.distanceTo(circle2.pc)[0];\r\n\r\n            if (Flatten.Utils.GT(dist, r1 + r2))               // circles too far, no intersections\r\n                return ip;\r\n\r\n            if (Flatten.Utils.LT(dist, Math.abs(r1 - r2)))     // one circle is contained within another, no intersections\r\n                return ip;\r\n\r\n            // Normalize vector.\r\n            vec.x /= dist;\r\n            vec.y /= dist;\r\n\r\n            let pt;\r\n\r\n            // Case of touching from outside or from inside - single intersection point\r\n            // TODO: check this specifically not sure if correct\r\n            if (Flatten.Utils.EQ(dist, r1 + r2) || Flatten.Utils.EQ(dist, Math.abs(r1 - r2))) {\r\n                pt = circle1.pc.translate(r1*vec.x, r1*vec.y);\r\n                ip.push(pt);\r\n                return ip;\r\n            }\r\n\r\n            // Case of two intersection points\r\n\r\n            // Distance from first center to center of common chord:\r\n            //   a = (r1^2 - r2^2 + d^2) / 2d\r\n            // Separate for better accuracy\r\n            let a = (r1*r1)/(2*dist) - (r2*r2)/(2*dist) + dist/2;\r\n\r\n            let mid_pt = circle1.pc.translate(a*vec.x, a*vec.y);\r\n            let h = Math.sqrt(r1*r1 - a*a);\r\n            // let norm;\r\n\r\n            // norm = vec.rotate90CCW().multiply(h);\r\n            pt = mid_pt.translate(vec.rotate90CCW().multiply(h));\r\n            ip.push(pt);\r\n\r\n            // norm = vec.rotate90CW();\r\n            pt = mid_pt.translate(vec.rotate90CW().multiply(h));\r\n            ip.push(pt);\r\n\r\n            return ip;\r\n        }\r\n\r\n        /**\r\n         * Return string to draw circle in svg\r\n         * @param {Object} attrs - an object with attributes of svg circle element,\r\n         * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n         * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n         * @returns {string}\r\n         */\r\n        svg(attrs = {}) {\r\n            let {stroke, strokeWidth, fill, fillOpacity, id, className} = attrs;\r\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n            return `\\n<circle cx=\"${this.pc.x}\" cy=\"${this.pc.y}\" r=\"${this.r}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" fill-opacity=\"${fillOpacity || 1.0}\" ${id_str} ${class_str} />`;\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return Object.assign({},this,{name:\"circle\"});\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Shortcut to create new circle\r\n     * @param args\r\n     */\r\n    Flatten.circle = (...args) => new Flatten.Circle(...args);\r\n};","/**\r\n * Created by Alex Bol on 3/10/2017.\r\n */\r\n\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function (Flatten) {\r\n    /**\r\n     * Class representing a segment\r\n     * @type {Segment}\r\n     */\r\n    Flatten.Segment = class Segment {\r\n        /**\r\n         *\r\n         * @param {Point} ps - start point\r\n         * @param {Point} pe - end point\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * Start point\r\n             * @type {Point}\r\n             */\r\n            this.ps = new Flatten.Point();\r\n            /**\r\n             * End Point\r\n             * @type {Point}\r\n             */\r\n            this.pe = new Flatten.Point();\r\n\r\n            if (args.length == 0) {\r\n                return;\r\n            }\r\n\r\n            if (args.length == 1 && args[0] instanceof Array && args[0].length == 4) {\r\n                let coords = args[0];\r\n                this.ps = new Flatten.Point(coords[0], coords[1]);\r\n                this.pe = new Flatten.Point(coords[2], coords[3]);\r\n                return;\r\n            }\r\n\r\n            if (args.length == 1 && args[0] instanceof Object && args[0].name === \"segment\") {\r\n                let {ps,pe} = args[0];\r\n                this.ps = new Flatten.Point(ps.x, ps.y);\r\n                this.pe = new Flatten.Point(pe.x, pe.y);\r\n                return;\r\n            }\r\n\r\n            if (args.length == 2 && args[0] instanceof Flatten.Point && args[1] instanceof Flatten.Point) {\r\n                this.ps = args[0].clone();\r\n                this.pe = args[1].clone();\r\n                return;\r\n            }\r\n\r\n            if (args.length == 4) {\r\n                this.ps = new Flatten.Point(args[0], args[1]);\r\n                this.pe = new Flatten.Point(args[2], args[3]);\r\n                return;\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Method clone copies segment and returns a new instance\r\n         * @returns {Segment}\r\n         */\r\n        clone() {\r\n            return new Flatten.Segment(this.start, this.end);\r\n        }\r\n\r\n        /**\r\n         * Start point\r\n         * @returns {Point}\r\n         */\r\n        get start() {\r\n            return this.ps;\r\n        }\r\n\r\n        /**\r\n         * End point\r\n         * @returns {Point}\r\n         */\r\n        get end() {\r\n            return this.pe;\r\n        }\r\n\r\n\r\n        /**\r\n         * Returns array of start and end point\r\n         * @returns [Point,Point]\r\n         */\r\n        get vertices() {\r\n            return [this.ps.clone(), this.pe.clone()];\r\n        }\r\n\r\n        /**\r\n         * Length of a segment\r\n         * @returns {number}\r\n         */\r\n        get length() {\r\n            return this.start.distanceTo(this.end)[0];\r\n        }\r\n\r\n        /**\r\n         * Slope of the line - angle to axe x in radians from 0 to 2PI\r\n         * @returns {number}\r\n         */\r\n        get slope() {\r\n            let vec = new Flatten.Vector(this.start, this.end);\r\n            return vec.slope;\r\n        }\r\n\r\n        /**\r\n         * Bounding box\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            return new Flatten.Box(\r\n                Math.min(this.start.x, this.end.x),\r\n                Math.min(this.start.y, this.end.y),\r\n                Math.max(this.start.x, this.end.x),\r\n                Math.max(this.start.y, this.end.y)\r\n            )\r\n        }\r\n\r\n        /**\r\n         * Returns true if equals to query segment, false otherwise\r\n         * @param {Seg} seg - query segment\r\n         * @returns {boolean}\r\n         */\r\n        equalTo(seg) {\r\n            return this.ps.equalTo(seg.ps) && this.pe.equalTo(seg.pe);\r\n        }\r\n\r\n        /**\r\n         * Returns true if segment contains point\r\n         * @param {Point} pt Query point\r\n         * @returns {boolean}\r\n         */\r\n        contains(pt) {\r\n            return Flatten.Utils.EQ_0(this.distanceToPoint(pt));\r\n        }\r\n\r\n        /**\r\n         * Returns array of intersection points between segment and other shape\r\n         * @param {Shape} shape - Shape of the one of supported types <br/>\r\n         * @returns {Point[]}\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Flatten.Point) {\r\n                return this.contains(shape) ? [shape] : [];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                return Segment.intersectSegment2Line(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                return Segment.intersectSegment2Segment(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                return Segment.intersectSegment2Circle(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                return Segment.intersectSegment2Arc(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                return Flatten.Polygon.intersectShape2Polygon(this, shape);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment from segment to shape and return as array [distance, shortest segment]\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n         * @returns {number} distance from segment to shape\r\n         * @returns {Segment} shortest segment between segment and shape (started at segment, ended at shape)\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n\r\n            if (shape instanceof Flatten.Point) {\r\n                let [dist, shortest_segment] = Distance.point2segment(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                let [dist, shortest_segment] = Distance.segment2circle(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                let [dist, shortest_segment] = Distance.segment2line(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                let [dist, shortest_segment] = Distance.segment2segment(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                let [dist, shortest_segment] = Distance.segment2arc(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                let [dist, shortest_segment] = Distance.shape2polygon(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.PlanarSet) {\r\n                let [dist, shortest_segment] = Distance.shape2planarSet(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns unit vector in the direction from start to end\r\n         * @returns {Vector}\r\n         */\r\n        tangentInStart() {\r\n            let vec = new Flatten.Vector(this.start, this.end);\r\n            return vec.normalize();\r\n        }\r\n\r\n        /**\r\n         * Return unit vector in the direction from end to start\r\n         * @returns {Vector}\r\n         */\r\n        tangentInEnd() {\r\n            let vec = new Flatten.Vector(this.end, this.start);\r\n            return vec.normalize();\r\n        }\r\n\r\n        /**\r\n         * Returns new segment with swapped start and end points\r\n         * @returns {Segment}\r\n         */\r\n        reverse() {\r\n            return new Segment(this.end, this.start);\r\n        }\r\n\r\n        /**\r\n         * When point belongs to segment, return array of two segments split by given point,\r\n         * if point is inside segment. Returns clone of this segment if query point is incident\r\n         * to start or end point of the segment. Returns empty array if point does not belong to segment\r\n         * @param {Point} pt Query point\r\n         * @returns {Segment[]}\r\n         */\r\n        split(pt) {\r\n            if (!this.contains(pt))\r\n                return [];\r\n\r\n            if (this.start.equalTo(this.end))\r\n                return [this.clone()];\r\n\r\n            if (this.start.equalTo(pt) || this.end.equalTo(pt))\r\n                return [this];\r\n\r\n            return [\r\n                new Flatten.Segment(this.start, pt),\r\n                new Flatten.Segment(pt, this.end)\r\n            ]\r\n        }\r\n\r\n        /**\r\n         * Return middle point of the segment\r\n         * @returns {Point}\r\n         */\r\n        middle() {\r\n            return new Flatten.Point((this.start.x + this.end.x)/2, (this.start.y + this.end.y)/2);\r\n        }\r\n\r\n        distanceToPoint(pt) {\r\n            let [dist, ...rest] = Flatten.Distance.point2segment(pt, this);\r\n            return dist;\r\n        };\r\n\r\n        definiteIntegral(ymin = 0.0) {\r\n            let dx = this.end.x - this.start.x;\r\n            let dy1 = this.start.y - ymin;\r\n            let dy2 = this.end.y - ymin;\r\n            return ( dx * (dy1 + dy2) / 2 );\r\n        }\r\n\r\n        /**\r\n         * Returns new segment translated by vector vec\r\n         * @param {Vector} vec\r\n         * @returns {Segment}\r\n         */\r\n        translate(...args) {\r\n            return new Segment(this.ps.translate(...args), this.pe.translate(...args));\r\n        }\r\n\r\n        /**\r\n         * Return new segment rotated by given angle around given point\r\n         * If point omitted, rotate around origin (0,0)\r\n         * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n         * @param {number} angle - rotation angle in radians\r\n         * @param {Point} center - center point, default is (0,0)\r\n         * @returns {Segment}\r\n         */\r\n        rotate(angle = 0, center = new Flatten.Point()) {\r\n            let m = new Flatten.Matrix();\r\n            m = m.translate(center.x, center.y).rotate(angle).translate(-center.x, -center.y);\r\n            return this.transform(m);\r\n        }\r\n\r\n        /**\r\n         * Return new segment transformed using affine transformation matrix\r\n         * @param {Matrix} matrix - affine transformation matrix\r\n         * @returns {Segment} - transformed segment\r\n         */\r\n        transform(matrix = new Flatten.Matrix()) {\r\n            return new Segment(this.ps.transform(matrix), this.pe.transform(matrix))\r\n        }\r\n\r\n        /**\r\n         * Returns true if segment start is equal to segment end up to DP_TOL\r\n         * @returns {boolean}\r\n         */\r\n        isZeroLength() {\r\n            return this.ps.equalTo(this.pe)\r\n        }\r\n\r\n        static intersectSegment2Line(seg, line) {\r\n            let ip = [];\r\n\r\n            // Boundary cases\r\n            if (seg.ps.on(line)) {\r\n                ip.push(seg.ps);\r\n            }\r\n            // If both ends lay on line, return two intersection points\r\n            if (seg.pe.on(line) && !seg.isZeroLength()) {\r\n                ip.push(seg.pe);\r\n            }\r\n\r\n            if (ip.length > 0) {\r\n                return ip;          // done, intersection found\r\n            }\r\n\r\n            // If zero-length segment and nothing found, return no intersections\r\n            if (seg.isZeroLength()) {\r\n                return ip;\r\n            }\r\n\r\n            // Not a boundary case, check if both points are on the same side and\r\n            // hence there is no intersection\r\n            if (seg.ps.leftTo(line) && seg.pe.leftTo(line) ||\r\n                !seg.ps.leftTo(line) && !seg.pe.leftTo(line)) {\r\n                return ip;\r\n            }\r\n\r\n            // Calculate intersection between lines\r\n            let line1 = new Flatten.Line(seg.ps, seg.pe);\r\n            return line1.intersect(line);\r\n        }\r\n\r\n        static intersectSegment2Segment(seg1, seg2) {\r\n            let ip = [];\r\n\r\n            // quick reject\r\n            if (seg1.box.not_intersect(seg2.box)) {\r\n                return ip;\r\n            }\r\n\r\n            // Special case of seg1 zero length\r\n            if (seg1.isZeroLength()) {\r\n                if (seg1.ps.on(seg2)) {\r\n                    ip.push(seg1.ps);\r\n                }\r\n                return ip;\r\n            }\r\n\r\n            // Special case of seg2 zero length\r\n            if (seg2.isZeroLength()) {\r\n                if (seg2.ps.on(seg1)) {\r\n                    ip.push(seg2.ps);\r\n                }\r\n                return ip;\r\n            }\r\n\r\n            // Neither seg1 nor seg2 is zero length\r\n            let line1 = new Flatten.Line(seg1.ps, seg1.pe);\r\n            let line2 = new Flatten.Line(seg2.ps, seg2.pe);\r\n\r\n            // Check overlapping between segments in case of incidence\r\n            // If segments touching, add one point. If overlapping, add two points\r\n            if (line1.incidentTo(line2)) {\r\n                if (seg1.ps.on(seg2)) {\r\n                    ip.push(seg1.ps);\r\n                }\r\n                if (seg1.pe.on(seg2)) {\r\n                    ip.push(seg1.pe);\r\n                }\r\n                if (seg2.ps.on(seg1) && !seg2.ps.equalTo(seg1.ps) && !seg2.ps.equalTo(seg1.pe)) {\r\n                    ip.push(seg2.ps);\r\n                }\r\n                if (seg2.pe.on(seg1) && !seg2.pe.equalTo(seg1.ps) && !seg2.pe.equalTo(seg1.pe)) {\r\n                    ip.push(seg2.pe);\r\n                }\r\n            }\r\n            else {                /* not incident - parallel or intersect */\r\n                // Calculate intersection between lines\r\n                let new_ip = line1.intersect(line2);\r\n                if (new_ip.length > 0 && new_ip[0].on(seg1) && new_ip[0].on(seg2)) {\r\n                    ip.push(new_ip[0]);\r\n                }\r\n            }\r\n\r\n            return ip;\r\n        }\r\n\r\n        static intersectSegment2Circle(segment, circle) {\r\n            let ips = [];\r\n\r\n            if (segment.box.not_intersect(circle.box)) {\r\n                return ips;\r\n            }\r\n\r\n            // Special case of zero length segment\r\n            if (segment.isZeroLength()) {\r\n                let [dist,shortest_segment] = segment.ps.distanceTo(circle.pc);\r\n                if (Flatten.Utils.EQ(dist, circle.r)) {\r\n                    ips.push(segment.ps);\r\n                }\r\n                return ips;\r\n            }\r\n\r\n            // Non zero-length segment\r\n            let line = new Flatten.Line(segment.ps, segment.pe);\r\n\r\n            let ips_tmp = line.intersect(circle);\r\n\r\n            for (let ip of ips_tmp) {\r\n                if (ip.on(segment)) {\r\n                    ips.push(ip);\r\n                }\r\n            }\r\n\r\n            return ips;\r\n        }\r\n\r\n        static intersectSegment2Arc(segment, arc) {\r\n            let ip = [];\r\n\r\n            if (segment.box.not_intersect(arc.box)) {\r\n                return ip;\r\n            }\r\n\r\n            // Special case of zero-length segment\r\n            if (segment.isZeroLength()) {\r\n                if (segment.ps.on(arc)) {\r\n                    ip.push(segment.ps);\r\n                }\r\n                return ip;\r\n            }\r\n\r\n            // Non-zero length segment\r\n            let line = new Flatten.Line(segment.ps, segment.pe);\r\n            let circle = new Flatten.Circle(arc.pc, arc.r);\r\n\r\n            let ip_tmp = line.intersect(circle);\r\n\r\n            for (let pt of ip_tmp) {\r\n                if (pt.on(segment) && pt.on(arc)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n            return ip;\r\n\r\n        }\r\n\r\n        /**\r\n         * Return string to draw segment in svg\r\n         * @param {Object} attrs - an object with attributes for svg path element,\r\n         * like \"stroke\", \"strokeWidth\" <br/>\r\n         * Defaults are stroke:\"black\", strokeWidth:\"1\"\r\n         * @returns {string}\r\n         */\r\n        svg(attrs = {}) {\r\n            let {stroke, strokeWidth, id, className} = attrs;\r\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n            return `\\n<line x1=\"${this.start.x}\" y1=\"${this.start.y}\" x2=\"${this.end.x}\" y2=\"${this.end.y}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" ${id_str} ${class_str} />`;\r\n\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return Object.assign({},this,{name:\"segment\"});\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Shortcut method to create new segment\r\n     */\r\n    Flatten.segment = (...args) => new Flatten.Segment(...args);\r\n};","/**\r\n * Created by Alex Bol on 3/10/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class representing a circular arc\r\n     * @type {Arc}\r\n     */\r\n    Flatten.Arc = class Arc {\r\n        /**\r\n         *\r\n         * @param {Point} pc - arc center\r\n         * @param {number} r - arc radius\r\n         * @param {number} startAngle - start angle in radians from 0 to 2*PI\r\n         * @param {number} endAngle - end angle in radians from 0 to 2*PI\r\n         * @param {boolean} counterClockwise - arc direction, true - clockwise, false - counter clockwise\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * Arc center\r\n             * @type {Point}\r\n             */\r\n            this.pc = new Flatten.Point();\r\n            /**\r\n             * Arc radius\r\n             * @type {number}\r\n             */\r\n            this.r = 1;\r\n            /**\r\n             * Arc start angle in radians\r\n             * @type {number}\r\n             */\r\n            this.startAngle = 0;\r\n            /**\r\n             * Arc end angle in radians\r\n             * @type {number}\r\n             */\r\n            this.endAngle = 2*Math.PI;\r\n            /**\r\n             * Arc orientation\r\n             * @type {boolean}\r\n             */\r\n            this.counterClockwise = Flatten.CCW;\r\n\r\n            if (args.length == 0)\r\n                return;\r\n\r\n            if (args.length == 1 && args[0] instanceof Object && args[0].name === \"arc\") {\r\n                let {pc, r, startAngle, endAngle, counterClockwise} = args[0];\r\n                this.pc = new Flatten.Point(pc.x, pc.y);\r\n                this.r = r;\r\n                this.startAngle = startAngle;\r\n                this.endAngle = endAngle;\r\n                this.counterClockwise = counterClockwise;\r\n                return;\r\n            }\r\n            else {\r\n                let [pc, r, startAngle, endAngle, counterClockwise] = [...args];\r\n                if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\r\n                if (r !== undefined) this.r = r;\r\n                if (startAngle !== undefined) this.startAngle = startAngle;\r\n                if (endAngle!== undefined) this.endAngle = endAngle;\r\n                if (counterClockwise !== undefined) this.counterClockwise = counterClockwise;\r\n                return;\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Return new instance of arc\r\n         * @returns {Arc}\r\n         */\r\n        clone() {\r\n            return new Flatten.Arc(this.pc.clone(), this.r, this.startAngle, this.endAngle, this.counterClockwise);\r\n        }\r\n\r\n        /**\r\n         * Get sweep angle in radians. Sweep angle is non-negative number from 0 to 2*PI\r\n         * @returns {number}\r\n         */\r\n        get sweep() {\r\n            if (Flatten.Utils.EQ(this.startAngle, this.endAngle))\r\n                return 0.0;\r\n            if (Flatten.Utils.EQ(Math.abs(this.startAngle - this.endAngle), Flatten.PIx2)) {\r\n                return Flatten.PIx2;\r\n            }\r\n            let sweep;\r\n            if (this.counterClockwise) {\r\n                sweep = Flatten.Utils.GT(this.endAngle, this.startAngle) ?\r\n                    this.endAngle - this.startAngle : this.endAngle - this.startAngle + Flatten.PIx2;\r\n            } else {\r\n                sweep = Flatten.Utils.GT(this.startAngle, this.endAngle) ?\r\n                    this.startAngle - this.endAngle : this.startAngle - this.endAngle + Flatten.PIx2;\r\n            }\r\n\r\n            if ( Flatten.Utils.GT(sweep, Flatten.PIx2) ) {\r\n                sweep -= Flatten.PIx2;\r\n            }\r\n            if ( Flatten.Utils.LT(sweep, 0) ) {\r\n                sweep += Flatten.PIx2;\r\n            }\r\n            return sweep;\r\n        }\r\n\r\n        /**\r\n         * Get start point of arc\r\n         * @returns {Point}\r\n         */\r\n        get start() {\r\n            let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\r\n            return p0.rotate(this.startAngle, this.pc);\r\n        }\r\n\r\n        /**\r\n         * Get end point of arc\r\n         * @returns {Point}\r\n         */\r\n        get end() {\r\n            let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\r\n            return p0.rotate(this.endAngle, this.pc);\r\n        }\r\n\r\n        /**\r\n         * Get center of arc\r\n         * @returns {Point}\r\n         */\r\n        get center() {\r\n            return this.pc.clone();\r\n        }\r\n\r\n        get vertices() {\r\n            return [this.start.clone(), this.end.clone()];\r\n        }\r\n\r\n        /**\r\n         * Get arc length\r\n         * @returns {number}\r\n         */\r\n        get length() {\r\n            return Math.abs(this.sweep*this.r);\r\n        }\r\n\r\n        /**\r\n         * Get bounding box of the arc\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            let func_arcs = this.breakToFunctional();\r\n            let box = func_arcs.reduce( (acc, arc) => acc.merge(arc.start.box), new Flatten.Box() );\r\n            box = box.merge(this.end.box);\r\n            return box;\r\n        }\r\n\r\n        /**\r\n         * Returns true if arc contains point, false otherwise\r\n         * @param {Point} pt - point to test\r\n         * @returns {boolean}\r\n         */\r\n        contains(pt) {\r\n            // first check if  point on circle (pc,r)\r\n            if (!Flatten.Utils.EQ(this.pc.distanceTo(pt)[0], this.r))\r\n                return false;\r\n\r\n            // point on circle\r\n\r\n            if (pt.equalTo(this.start))\r\n                return true;\r\n\r\n            let angle = new Flatten.Vector(this.pc, pt).slope;\r\n            let test_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise);\r\n            return Flatten.Utils.LE(test_arc.length, this.length);\r\n        }\r\n\r\n        /**\r\n         * When given point belongs to arc, return array of two arcs split by this point. If points is incident\r\n         * to start or end point of the arc, return clone of the arc. If point does not belong to the arcs, return\r\n         * empty array.\r\n         * @param {Point} pt Query point\r\n         * @returns {Arc[]}\r\n         */\r\n        split(pt) {\r\n            if (!this.contains(pt))\r\n                return [];\r\n\r\n            if (Flatten.Utils.EQ_0(this.sweep))\r\n                return [this.clone()];\r\n\r\n            if (this.start.equalTo(pt) || this.end.equalTo(pt))\r\n                return [this.clone()];\r\n\r\n            let angle = new Flatten.Vector(this.pc, pt).slope;\r\n\r\n            return [\r\n                new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise),\r\n                new Flatten.Arc(this.pc, this.r, angle, this.endAngle, this.counterClockwise)\r\n            ]\r\n        }\r\n\r\n        /**\r\n         * Return middle point of the arc\r\n         * @returns {Point}\r\n         */\r\n        middle() {\r\n            let endAngle = this.counterClockwise ? this.startAngle + this.sweep/2 : this.startAngle - this.sweep/2;\r\n            let arc = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\r\n            return arc.end;\r\n        }\r\n\r\n        /**\r\n         * Returns chord height (\"sagitta\") of the arc\r\n         * @returns {number}\r\n         */\r\n        chordHeight() {\r\n            return  (1.0 - Math.cos(Math.abs(this.sweep/2.0))) * this.r;\r\n        }\r\n\r\n        /**\r\n         * Returns array of intersection points between arc and other shape\r\n         * @param {Shape} shape Shape of the one of supported types <br/>\r\n         * @returns {Points[]}\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Flatten.Point) {\r\n                return this.contains(shape) ? [shape] : [];\r\n            }\r\n            if (shape instanceof Flatten.Line) {\r\n                return shape.intersect(this);\r\n            }\r\n            if (shape instanceof Flatten.Circle) {\r\n                return Arc.intersectArc2Circle(this, shape);\r\n            }\r\n            if (shape instanceof Flatten.Segment) {\r\n                return shape.intersect(this);\r\n            }\r\n            if (shape instanceof Flatten.Arc) {\r\n                return Arc.intersectArc2Arc(this, shape);\r\n            }\r\n            if (shape instanceof Flatten.Polygon) {\r\n                return Flatten.Polygon.intersectShape2Polygon(this, shape);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment from arc to shape and return array [distance, shortest segment]\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n         * @returns {number} distance from arc to shape\r\n         * @returns {Segment} shortest segment between arc and shape (started at arc, ended at shape)\r\n\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n\r\n            if (shape instanceof Flatten.Point) {\r\n                let [dist, shortest_segment] = Distance.point2arc(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                let [dist, shortest_segment] = Distance.arc2circle(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                let [dist, shortest_segment] = Distance.arc2line(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                let [dist, shortest_segment] = Distance.segment2arc(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                let [dist, shortest_segment] = Distance.arc2arc(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                let [dist, shortest_segment] = Distance.shape2polygon(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.PlanarSet) {\r\n                let [dist, shortest_segment] = Distance.shape2planarSet(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Breaks arc in extreme point 0, pi/2, pi, 3*pi/2 and returns array of sub-arcs\r\n         * @returns {Arcs[]}\r\n         */\r\n        breakToFunctional() {\r\n            let func_arcs_array = [];\r\n            let angles = [0, Math.PI/2, 2*Math.PI/2, 3*Math.PI/2];\r\n            let pts = [\r\n                this.pc.translate(this.r,0),\r\n                this.pc.translate(0,this.r),\r\n                this.pc.translate(-this.r,0),\r\n                this.pc.translate(0,-this.r)\r\n            ];\r\n\r\n            // If arc contains extreme point,\r\n            // create test arc started at start point and ended at this extreme point\r\n            let test_arcs = [];\r\n            for (let i=0; i < 4; i++) {\r\n                if (pts[i].on(this)) {\r\n                    test_arcs.push(new Flatten.Arc(this.pc, this.r, this.startAngle, angles[i], this.counterClockwise));\r\n                }\r\n            }\r\n\r\n            if (test_arcs.length == 0) {                  // arc does contain any extreme point\r\n                func_arcs_array.push(this.clone());\r\n            }\r\n            else {                                        // arc passes extreme point\r\n                // sort these arcs by length\r\n                test_arcs.sort((arc1, arc2) => arc1.length - arc2.length);\r\n\r\n                for (let i = 0; i < test_arcs.length; i++) {\r\n                    let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\r\n                    let new_arc;\r\n                    if (prev_arc) {\r\n                        new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, test_arcs[i].endAngle, this.counterClockwise);\r\n                    }\r\n                    else {\r\n                        new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, test_arcs[i].endAngle, this.counterClockwise);\r\n                    }\r\n                    if (!Flatten.Utils.EQ_0(new_arc.length)) {\r\n                        func_arcs_array.push(new_arc.clone());\r\n                    }\r\n                }\r\n\r\n                // add last sub arc\r\n                let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\r\n                let new_arc;\r\n                if (prev_arc) {\r\n                    new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, this.endAngle, this.counterClockwise);\r\n                }\r\n                else {\r\n                    new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, this.endAngle, this.counterClockwise);\r\n                }\r\n                if (!Flatten.Utils.EQ_0(new_arc.length)) {\r\n                    func_arcs_array.push(new_arc.clone());\r\n                }\r\n            }\r\n            return func_arcs_array;\r\n        }\r\n\r\n        /**\r\n         * Return tangent unit vector in the start point in the direction from start to end\r\n         * @returns {Vector}\r\n         */\r\n        tangentInStart() {\r\n            let vec = new Flatten.Vector(this.pc, this.start);\r\n            let angle = this.counterClockwise ? Math.PI/2. : -Math.PI/2.;\r\n            let tangent = vec.rotate(angle).normalize();\r\n            return tangent;\r\n        }\r\n\r\n        /**\r\n         * Return tangent unit vector in the end point in the direction from end to start\r\n         * @returns {Vector}\r\n         */\r\n        tangentInEnd() {\r\n            let vec = new Flatten.Vector(this.pc, this.end);\r\n            let angle = this.counterClockwise ? -Math.PI/2. : Math.PI/2.;\r\n            let tangent = vec.rotate(angle).normalize();\r\n            return tangent;\r\n        }\r\n\r\n        /**\r\n         * Returns new arc with swapped start and end angles and reversed direction\r\n         * @returns {Arc}\r\n         */\r\n        reverse() {\r\n            return new Arc(this.pc, this.r, this.endAngle, this.startAngle, !this.counterClockwise);\r\n        }\r\n\r\n        /**\r\n         * Returns new arc translated by vector vec\r\n         * @param {Vector} vec\r\n         * @returns {Segment}\r\n         */\r\n        translate(...args) {\r\n            let arc = this.clone();\r\n            arc.pc = this.pc.translate(...args);\r\n            return arc;\r\n        }\r\n\r\n        /**\r\n         * Return new segment rotated by given angle around given point\r\n         * If point omitted, rotate around origin (0,0)\r\n         * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n         * @param {number} angle - rotation angle in radians\r\n         * @param {Point} center - center point, default is (0,0)\r\n         * @returns {Arc}\r\n         */\r\n        rotate(angle = 0, center = new Flatten.Point()) {\r\n            let m = new Flatten.Matrix();\r\n            m = m.translate(center.x, center.y).rotate(angle).translate(-center.x, -center.y);\r\n            return this.transform(m);\r\n        }\r\n\r\n        /**\r\n         * Return new arc transformed using affine transformation matrix <br/>\r\n         * Note, that non-equal scaling by x and y (matrix[0] != matrix[3]) produce illegal result\r\n         * TODO: support non-equal scaling arc to ellipse or throw exception ?\r\n         * @param {Matrix} matrix - affine transformation matrix\r\n         * @returns {Arc}\r\n         */\r\n        transform(matrix = new Flatten.Matrix()) {\r\n            let newStart = this.start.transform(matrix);\r\n            let newEnd = this.end.transform(matrix);\r\n            let newCenter = this.pc.transform(matrix);\r\n            let arc = Arc.arcSE(newCenter, newStart, newEnd, this.counterClockwise);\r\n            return arc;\r\n        }\r\n\r\n        static arcSE(center, start, end, counterClockwise) {\r\n            let {vector} = Flatten;\r\n            let startAngle = vector(center,start).slope;\r\n            let endAngle = vector(center, end).slope;\r\n            if (Flatten.Utils.EQ(startAngle, endAngle)) {\r\n                endAngle += 2*Math.PI;\r\n                counterClockwise = true;\r\n            }\r\n            let r = vector(center, start).length;\r\n\r\n            return new Arc(center, r, startAngle, endAngle, counterClockwise);\r\n        }\r\n\r\n        static intersectArc2Arc(arc1, arc2) {\r\n            var ip = [];\r\n\r\n            if (arc1.box.not_intersect(arc2.box)) {\r\n                return ip;\r\n            }\r\n\r\n            // Special case: overlapping arcs\r\n            // May return up to 4 intersection points\r\n            if (arc1.pc.equalTo(arc2.pc) && Flatten.Utils.EQ(arc1.r, arc2.r)) {\r\n                let pt;\r\n\r\n                pt = arc1.start;\r\n                if (pt.on(arc2))\r\n                    ip.push(pt);\r\n\r\n                pt = arc1.end;\r\n                if (pt.on(arc2))\r\n                    ip.push(pt);\r\n\r\n                pt = arc2.start;\r\n                if (pt.on(arc1)) ip.push(pt);\r\n\r\n                pt = arc2.end;\r\n                if (pt.on(arc1)) ip.push(pt);\r\n\r\n                return ip;\r\n            }\r\n\r\n            // Common case\r\n            let circle1 = new Flatten.Circle(arc1.pc, arc1.r);\r\n            let circle2 = new Flatten.Circle(arc2.pc, arc2.r);\r\n            let ip_tmp =  circle1.intersect(circle2);\r\n            for (let pt of ip_tmp) {\r\n                if (pt.on(arc1) && pt.on(arc2)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n            return ip;\r\n        }\r\n\r\n        static intersectArc2Circle(arc, circle) {\r\n            let ip = [];\r\n\r\n            if (arc.box.not_intersect(circle.box)) {\r\n                return ip;\r\n            }\r\n\r\n            // Case when arc center incident to circle center\r\n            // Return arc's end points as 2 intersection points\r\n            if (circle.pc.equalTo(arc.pc) && Flatten.Utils.EQ(circle.r, arc.r)) {\r\n                ip.push(arc.start);\r\n                ip.push(arc.end);\r\n                return ip;\r\n            }\r\n\r\n            // Common case\r\n            let circle1 = circle;\r\n            let circle2 = new Flatten.Circle(arc.pc, arc.r);\r\n            let ip_tmp = circle1.intersect(circle2);\r\n            for (let pt of ip_tmp) {\r\n                if (pt.on(arc)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n            return ip;\r\n        }\r\n\r\n        definiteIntegral(ymin=0) {\r\n            let f_arcs = this.breakToFunctional();\r\n            let area = f_arcs.reduce( (acc, arc) => acc + arc.circularSegmentDefiniteIntegral(ymin), 0.0 );\r\n            return area;\r\n        }\r\n\r\n        circularSegmentDefiniteIntegral(ymin) {\r\n            let line = new Flatten.Line(this.start, this.end);\r\n            let onLeftSide = this.pc.leftTo(line);\r\n            let segment = new Flatten.Segment(this.start, this.end);\r\n            let areaTrapez = segment.definiteIntegral(ymin);\r\n            let areaCircularSegment = this.circularSegmentArea();\r\n            let area = onLeftSide ? areaTrapez - areaCircularSegment : areaTrapez + areaCircularSegment;\r\n            return area;\r\n        }\r\n\r\n        circularSegmentArea() {\r\n            return (0.5*this.r*this.r*(this.sweep - Math.sin(this.sweep)))\r\n        }\r\n\r\n        /**\r\n         * Return string to draw arc in svg\r\n         * @param {Object} attrs - an object with attributes of svg path element,\r\n         * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n         * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n         * @returns {string}\r\n         */\r\n        svg(attrs = {}) {\r\n            let largeArcFlag = this.sweep <= Math.PI ? \"0\" : \"1\";\r\n            let sweepFlag = this.counterClockwise ? \"1\" : \"0\";\r\n            let {stroke, strokeWidth, fill, id, className} = attrs;\r\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n            if (Flatten.Utils.EQ(this.sweep, 2*Math.PI)) {\r\n                let circle = new Flatten.Circle(this.pc, this.r);\r\n                return circle.svg(attrs);\r\n            }\r\n            else {\r\n                return `\\n<path d=\"M${this.start.x},${this.start.y}\r\n                             A${this.r},${this.r} 0 ${largeArcFlag},${sweepFlag} ${this.end.x},${this.end.y}\"\r\n                    stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" ${id_str} ${class_str} />`\r\n            }\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return Object.assign({},this,{name:\"arc\"});\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Function to create arc equivalent to \"new\" constructor\r\n     * @param args\r\n     */\r\n    Flatten.arc = (...args) => new Flatten.Arc(...args);\r\n};","/**\r\n * Created by Alex Bol on 3/7/2017.\r\n */\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class Box represent bounding box of the shape\r\n     * @type {Box}\r\n     */\r\n    Flatten.Box = class Box {\r\n        /**\r\n         *\r\n         * @param {number} xmin - minimal x coordinate\r\n         * @param {number} ymin - minimal y coordinate\r\n         * @param {number} xmax - maximal x coordinate\r\n         * @param {number} ymax - maximal y coordinate\r\n         */\r\n        constructor(xmin=undefined, ymin=undefined, xmax=undefined, ymax=undefined) {\r\n            /**\r\n             * Minimal x coordinate\r\n             * @type {number}\r\n             */\r\n            this.xmin = xmin;\r\n            /**\r\n             * Minimal y coordinate\r\n             * @type {number}\r\n             */\r\n            this.ymin = ymin;\r\n            /**\r\n             * Maximal x coordinate\r\n             * @type {number}\r\n             */\r\n            this.xmax = xmax;\r\n            /**\r\n             * Maximal y coordinate\r\n             * @type {number}\r\n             */\r\n            this.ymax = ymax;\r\n        }\r\n\r\n        /**\r\n         * Clones and returns new instance of box\r\n         * @returns {Box}\r\n         */\r\n        clone() {\r\n            return new Box(this.xmin, this.ymin, this.xmax, this.ymax);\r\n        }\r\n\r\n        /**\r\n         * Property low need for interval tree interface\r\n         * @returns {Point}\r\n         */\r\n        get low() {\r\n            return new Flatten.Point(this.xmin, this.ymin);\r\n        }\r\n\r\n        /**\r\n         * Property high need for interval tree interface\r\n         * @returns {Point}\r\n         */\r\n        get high() {\r\n            return new Flatten.Point(this.xmax, this.ymax);\r\n        }\r\n\r\n        /**\r\n         * Property max returns the box itself !\r\n         * @returns {Box}\r\n         */\r\n        get max() {\r\n            return this.clone();\r\n        }\r\n\r\n        /**\r\n         * Return center of the box\r\n         * @returns {Point}\r\n         */\r\n        get center() {\r\n            return new Flatten.Point( (this.xmin + this.xmax)/2, (this.ymin + this.ymax)/2 );\r\n        }\r\n\r\n        /**\r\n         * Returns true if not intersected with other box\r\n         * @param {Box} other_box - other box to test\r\n         * @returns {boolean}\r\n         */\r\n        not_intersect(other_box) {\r\n            return (\r\n                this.xmax < other_box.xmin ||\r\n                this.xmin > other_box.xmax ||\r\n                this.ymax < other_box.ymin ||\r\n                this.ymin > other_box.ymax\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Returns true if intersected with other box\r\n         * @param {Box} other_box - Query box\r\n         * @returns {boolean}\r\n         */\r\n        intersect(other_box) {\r\n            return !this.not_intersect(other_box);\r\n        }\r\n\r\n        /**\r\n         * Returns new box merged with other box\r\n         * @param {Box} other_box - Other box to merge with\r\n         * @returns {Box}\r\n         */\r\n        merge(other_box) {\r\n            return new Box(\r\n                this.xmin === undefined ? other_box.xmin : Math.min(this.xmin, other_box.xmin),\r\n                this.ymin === undefined ? other_box.ymin : Math.min(this.ymin, other_box.ymin),\r\n                this.xmax === undefined ? other_box.xmax : Math.max(this.xmax, other_box.xmax),\r\n                this.ymax === undefined ? other_box.ymax : Math.max(this.ymax, other_box.ymax)\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Defines predicate \"less than\" between two boxes. Need for interval index\r\n         * @param {Box} other_box - other box\r\n         * @returns {boolean} - true if this box less than other box, false otherwise\r\n         */\r\n        less_than(other_box) {\r\n            if (this.low.lessThan(other_box.low))\r\n                return true;\r\n            if (this.low.equalTo(other_box.low) && this.high.lessThan(other_box.high))\r\n                return true;\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Returns true if this box is equal to other box, false otherwise\r\n         * @param {Box} other_box - query box\r\n         * @returns {boolean}\r\n         */\r\n        equal_to(other_box) {\r\n            return (this.low.equalTo(other_box.low) && this.high.equalTo(other_box.high));\r\n        }\r\n\r\n        output() {\r\n            return this.clone();\r\n        }\r\n\r\n        maximal_val(box1, box2) {\r\n            // return pt1.lessThan(pt2) ? pt2.clone() : pt1.clone();\r\n            return box1.merge(box2);\r\n        }\r\n\r\n        val_less_than(pt1, pt2) {\r\n            return pt1.lessThan(pt2);\r\n        }\r\n\r\n        /**\r\n         * Set new values to the box object\r\n         * @param {number} xmin - miminal x coordinate\r\n         * @param {number} ymin - minimal y coordinate\r\n         * @param {number} xmax - maximal x coordinate\r\n         * @param {number} ymax - maximal y coordinate\r\n         */\r\n        set(xmin, ymin, xmax, ymax) {\r\n            this.xmin = xmin;\r\n            this.ymin = ymin;\r\n            this.xmax = xmax;\r\n            this.ymax = ymax;\r\n        }\r\n\r\n        /**\r\n         * Return string to draw circle in svg\r\n         * @param {Object} attrs - an object with attributes of svg rectangle element,\r\n         * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n         * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n         * @returns {string}\r\n         */\r\n        svg(attrs = {}) {\r\n            let {stroke, strokeWidth, fill, id, className} = attrs;\r\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n            let width = this.xmax - this.xmin;\r\n            let height = this.ymax - this.ymin;\r\n\r\n            return `\\n<rect x=\"${this.xmin}\" y=\"${this.ymin}\" width=${width} height=${height} stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" ${id_str} ${class_str} />`;\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Shortcut to create new circle\r\n     * @param args\r\n     * @returns {Box}\r\n     */\r\n    Flatten.box = (...args) => new Flatten.Box(...args);\r\n\r\n};\r\n","/**\r\n * Created by Alex Bol on 3/17/2017.\r\n */\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class representing an edge of polygon. Edge shape may be Segment or Arc.\r\n     * Each edge contains references to the next and previous edges in the face of the polygon.\r\n     *\r\n     * @type {Edge}\r\n     */\r\n    Flatten.Edge = class Edge {\r\n        /**\r\n         * Construct new instance of edge\r\n         * @param {Shape} shape Shape of type Segment of Arc\r\n         */\r\n        constructor(shape) {\r\n            /**\r\n             * Shape of the edge: Segment or Arc\r\n             */\r\n            this.shape = shape;\r\n            /**\r\n             * Pointer to the next edge in the face\r\n             */\r\n            this.next;\r\n            /**\r\n             * Pointer to the previous edge in the face\r\n             */\r\n            this.prev;\r\n            /**\r\n             * Pointer to the face containing this edge\r\n             * @type {Face}\r\n             */\r\n            this.face;\r\n            /**\r\n             * \"Arc distance\" from the face start\r\n             * @type {number}\r\n             */\r\n            this.arc_length = 0;\r\n            /**\r\n             * Start inclusion flag (inside/outside/boundary)\r\n             * @type {Boolean}\r\n             */\r\n            this.bvStart = undefined;\r\n            /**\r\n             * End inclusion flag (inside/outside/boundary)\r\n             * @type {Boolean}\r\n             */\r\n            this.bvEnd = undefined;\r\n            /**\r\n             * Edge inclusion flag (Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY)\r\n             * @type {*}\r\n             */\r\n            this.bv = undefined;\r\n            /**\r\n             * Overlap flag for boundary edge (Flatten.OVERLAP_SAME/Flatten.OVERLAP_OPPOSITE)\r\n             * @type {*}\r\n             */\r\n            this.overlap = undefined;\r\n        }\r\n\r\n        /**\r\n         * Get edge start point\r\n         */\r\n        get start() {\r\n            return this.shape.start;\r\n        }\r\n\r\n        /**\r\n         * Get edge end point\r\n         */\r\n        get end() {\r\n            return this.shape.end;\r\n        }\r\n\r\n        /**\r\n         * Get edge length\r\n         */\r\n        get length() {\r\n            return this.shape.length;\r\n        }\r\n\r\n        /**\r\n         * Get bounding box of the edge\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            return this.shape.box;\r\n        }\r\n\r\n        isSegment() {\r\n            return this.shape instanceof Flatten.Segment;\r\n        }\r\n\r\n        isArc() {\r\n            return this.shape instanceof Flatten.Arc;\r\n        }\r\n        /**\r\n         * Get middle point of the edge\r\n         * @returns {Point}\r\n         */\r\n        middle() {\r\n            return this.shape.middle();\r\n        }\r\n\r\n        /**\r\n         * Returns true if point belongs to the edge, false otherwise\r\n         * @param {Point} pt - test point\r\n         */\r\n        contains(pt) {\r\n            return this.shape.contains(pt);\r\n        }\r\n\r\n        /**\r\n         * Set inclusion flag of the edge with respect to another polygon\r\n         * Inclusion flag is one of Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY\r\n         * @param polygon\r\n         */\r\n        setInclusion(polygon) {\r\n            if (this.bv !== undefined) return this.bv;\r\n\r\n            if (this.bvStart === undefined) {\r\n                this.bvStart = Flatten.ray_shoot(polygon, this.start);\r\n            }\r\n            if (this.bvEnd === undefined) {\r\n                this.bvEnd = Flatten.ray_shoot(polygon, this.end);\r\n            }\r\n            /* At least one end outside - the whole edge outside */\r\n            if (this.bvStart === Flatten.OUTSIDE || this.bvEnd == Flatten.OUTSIDE) {\r\n                this.bv = Flatten.OUTSIDE;\r\n            }\r\n            /* At least one end inside - the whole edge inside */\r\n            else if (this.bvStart === Flatten.INSIDE || this.bvEnd == Flatten.INSIDE) {\r\n                this.bv = Flatten.INSIDE;\r\n            }\r\n            /* Both are boundary - check the middle point */\r\n            else {\r\n                let bvMiddle = Flatten.ray_shoot(polygon, this.middle());\r\n                this.bv = bvMiddle;\r\n            }\r\n            return this.bv;\r\n        }\r\n\r\n        /**\r\n         * Set overlapping between two coincident boundary edges\r\n         * Overlapping flag is one of Flatten.OVERLAP_SAME or Flatten.OVERLAP_OPPOSITE\r\n         * @param edge\r\n         */\r\n        setOverlap(edge) {\r\n            let flag = undefined;\r\n            let shape1 = this.shape;\r\n            let shape2 = edge.shape;\r\n\r\n            if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Segment) {\r\n                if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end)) {\r\n                    flag = Flatten.OVERLAP_SAME;\r\n                }\r\n                else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start)) {\r\n                    flag = Flatten.OVERLAP_OPPOSITE;\r\n                }\r\n            }\r\n            else if (shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Arc) {\r\n                if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && /*shape1.counterClockwise === shape2.counterClockwise &&*/\r\n                    shape1.middle().equalTo(shape2.middle())) {\r\n                    flag = Flatten.OVERLAP_SAME;\r\n                }\r\n                else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && /*shape1.counterClockwise !== shape2.counterClockwise &&*/\r\n                    shape1.middle().equalTo(shape2.middle())) {\r\n                    flag = Flatten.OVERLAP_OPPOSITE;\r\n                }\r\n            }\r\n            else if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Arc ||\r\n                shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Segment) {\r\n                if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && shape1.middle().equalTo(shape2.middle())) {\r\n                    flag = Flatten.OVERLAP_SAME;\r\n                }\r\n                else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && shape1.middle().equalTo(shape2.middle())) {\r\n                    flag = Flatten.OVERLAP_OPPOSITE;\r\n                }\r\n            }\r\n\r\n            /* Do not update overlap flag if already set on previous chain */\r\n            if (this.overlap === undefined) this.overlap = flag;\r\n            if (edge.overlap === undefined) edge.overlap = flag;\r\n        }\r\n\r\n        svg() {\r\n            if (this.shape instanceof Flatten.Segment) {\r\n                return ` L${this.shape.end.x},${this.shape.end.y}`;\r\n            }\r\n            else if (this.shape instanceof  Flatten.Arc) {\r\n                let arc = this.shape;\r\n                let largeArcFlag;\r\n                let sweepFlag = arc.counterClockwise ? \"1\" : \"0\";\r\n\r\n                // Draw full circe arc as special case: split it into two half-circles\r\n                if (Flatten.Utils.EQ(arc.sweep, 2*Math.PI)) {\r\n                    let sign = arc.counterClockwise ? 1 : -1;\r\n                    let halfArc1 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle, arc.startAngle + sign*Math.PI, arc.counterClockwise);\r\n                    let halfArc2 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle + sign*Math.PI, arc.endAngle, arc.counterClockwise);\r\n\r\n                    largeArcFlag = \"0\";\r\n\r\n                    return ` A${halfArc1.r},${halfArc1.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc1.end.x},${halfArc1.end.y}\r\n                    A${halfArc2.r},${halfArc2.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc2.end.x},${halfArc2.end.y}`\r\n                }\r\n                else {\r\n                    largeArcFlag = arc.sweep <= Math.PI ? \"0\" : \"1\";\r\n\r\n                    return ` A${arc.r},${arc.r} 0 ${largeArcFlag},${sweepFlag} ${arc.end.x},${arc.end.y}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        toJSON() {\r\n            return this.shape.toJSON();\r\n        }\r\n    };\r\n};","/**\r\n * Created by Alex Bol on 3/17/2017.\r\n */\r\n\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function (Flatten) {\r\n    let {Point, point, Segment, segment, Arc, Box, Edge, Circle} = Flatten;\r\n\r\n    /**\r\n     * Class representing a face (closed loop) in a [polygon]{@link Flatten.Polygon} object.\r\n     * Face is a circular bidirectional linked list of [edges]{@link Flatten.Edge}.\r\n     * Face object cannot be instantiated with a constructor.\r\n     * Instead, use [polygon.addFace()]{@link Flatten.Polygon#addFace} method.\r\n     * <br/>\r\n     * Note, that face only set entry point to the linked list of edges but does not contain edges by itself.\r\n     * Container of edges is a property of the polygon object. <br/>\r\n     *\r\n     * @example\r\n     * // Face implements \"next\" iterator which enables to iterate edges in for loop:\r\n     * for (let edge of face) {\r\n     *      console.log(edge.shape.length)     // do something\r\n     * }\r\n     *\r\n     * // Instead, it is possible to iterate edges as linked list, starting from face.first:\r\n     * let edge = face.first;\r\n     * do {\r\n     *   console.log(edge.shape.length);   // do something\r\n     *   edge = edge.next;\r\n     * } while (edge != face.first)\r\n     */\r\n    Flatten.Face = class Face {\r\n        constructor(polygon, ...args) {\r\n            /**\r\n             * Reference to the first edge in face\r\n             */\r\n            this.first;\r\n            /**\r\n             * Reference to the last edge in face\r\n             */\r\n            this.last;\r\n\r\n            this._box = undefined;  // new Box();\r\n            this._orientation = undefined;\r\n\r\n            if (args.length == 0) {\r\n                return;\r\n            }\r\n\r\n            /* If passed an array it supposed to be:\r\n             1) array of shapes that performs close loop or\r\n             2) array of points that performs set of vertices\r\n             */\r\n            if (args.length == 1) {\r\n                if (args[0] instanceof Array) {\r\n                    // let argsArray = args[0];\r\n                    let shapes = args[0];  // argsArray[0];\r\n                    if (shapes.length == 0)\r\n                        return;\r\n\r\n                    if (shapes.every((shape) => {\r\n                            return shape instanceof Point\r\n                        })) {\r\n                        let segments = Face.points2segments(shapes);\r\n                        this.shapes2face(polygon.edges, segments);\r\n                    }\r\n                    else if (shapes.every((shape) => {\r\n                            return (shape instanceof Segment || shape instanceof Arc)\r\n                        })) {\r\n                        this.shapes2face(polygon.edges, shapes);\r\n                    }\r\n                    // this is from JSON.parse object\r\n                    else if (shapes.every((shape) => {\r\n                            return (shape.name === \"segment\" || shape.name === \"arc\")\r\n                        })) {\r\n                        let flattenShapes = [];\r\n                        for (let shape of shapes) {\r\n                            let flattenShape;\r\n                            if (shape.name === \"segment\") {\r\n                                flattenShape = new Segment(shape);\r\n                            }\r\n                            else {\r\n                                flattenShape = new Arc(shape);\r\n                            }\r\n                            flattenShapes.push(flattenShape);\r\n                        }\r\n                        this.shapes2face(polygon.edges, flattenShapes);\r\n                    }\r\n                }\r\n                /* Create new face and copy edges into polygon.edges set */\r\n                else if (args[0] instanceof Face) {\r\n                    let face = args[0];\r\n                    this.first = face.first;\r\n                    this.last = face.last;\r\n                    for (let edge of face) {\r\n                        polygon.edges.add(edge);\r\n                    }\r\n                }\r\n                /* Instantiate face from circle circle in CCW orientation */\r\n                else if (args[0] instanceof Circle) {\r\n                    this.shapes2face(polygon.edges, [args[0].toArc(Flatten.CCW)]);\r\n                }\r\n                /* Instantiate face from a box in CCW orientation */\r\n                else if (args[0] instanceof Box) {\r\n                    let box = args[0];\r\n                    this.shapes2face(polygon.edges, [\r\n                        segment(point(box.xmin, box.ymin), point(box.xmax, box.ymin)),\r\n                        segment(point(box.xmax, box.ymin), point(box.xmax, box.ymax)),\r\n                        segment(point(box.xmax, box.ymax), point(box.xmin, box.ymax)),\r\n                        segment(point(box.xmin, box.ymax), point(box.xmin, box.ymin))\r\n                    ]);\r\n                }\r\n            }\r\n            /* If passed two edges, consider them as start and end of the face loop */\r\n            /* THIS METHOD WILL BE USED BY BOOLEAN OPERATIONS */\r\n            /* Assume that edges already copied to polygon.edges set in the clip algorithm !!! */\r\n            if (args.length == 2 && args[0] instanceof Edge && args[1] instanceof Edge) {\r\n                this.first = args[0];                          // first edge in face or undefined\r\n                this.last = args[1];                           // last edge in face or undefined\r\n                this.last.next = this.first;\r\n                this.first.prev = this.last;\r\n\r\n                // set arc length\r\n                this.setArcLength();\r\n                /*\r\n                 let edge = this.first;\r\n                 edge.arc_length = 0;\r\n                 edge = edge.next;\r\n                 while (edge !== this.first) {\r\n                 edge.arc_length = edge.prev.arc_length + edge.prev.length;\r\n                 edge = edge.next;\r\n                 }\r\n                 */\r\n\r\n                // this.box = this.getBox();\r\n                // this.orientation = this.getOrientation();      // face direction cw or ccw\r\n            }\r\n        }\r\n\r\n        [Symbol.iterator]() {\r\n            let edge = undefined;\r\n            return {\r\n                next: () => {\r\n                    let value = edge ? edge : this.first;\r\n                    let done = this.first ? (edge ? edge === this.first : false) : true;\r\n                    edge = value ? value.next : undefined;\r\n                    return {value: value, done: done};\r\n                }\r\n            };\r\n        };\r\n\r\n        /**\r\n         * Return array of edges from first to last\r\n         * @returns {Array}\r\n         */\r\n        get edges() {\r\n            let face_edges = [];\r\n            for (let edge of this) {\r\n                face_edges.push(edge);\r\n            }\r\n            return face_edges;\r\n        }\r\n\r\n        /**\r\n         * Return number of edges in the face\r\n         * @returns {number}\r\n         */\r\n        get size() {\r\n            let counter = 0;\r\n            for (let edge of this) {\r\n                counter++;\r\n            }\r\n            return counter;\r\n        }\r\n\r\n        /**\r\n         * Return bounding box of the face\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            if (this._box === undefined) {\r\n                let box = new Flatten.Box();\r\n                for (let edge of this) {\r\n                    box = box.merge(edge.box);\r\n                }\r\n                this._box = box;\r\n            }\r\n            return this._box;\r\n        }\r\n\r\n        static points2segments(points) {\r\n            let segments = [];\r\n            for (let i = 0; i < points.length; i++) {\r\n                segments.push(new Segment(points[i], points[(i + 1) % points.length]));\r\n            }\r\n            return segments;\r\n        }\r\n\r\n        shapes2face(edges, shapes) {\r\n            for (let shape of shapes) {\r\n                let edge = new Edge(shape);\r\n                this.append(edges, edge);\r\n                // this.box = this.box.merge(shape.box);\r\n                // edges.add(edge);\r\n            }\r\n            // this.orientation = this.getOrientation();              // face direction cw or ccw\r\n        }\r\n\r\n        /**\r\n         * Returns true if face is empty, false otherwise\r\n         * @returns {boolean}\r\n         */\r\n        isEmpty() {\r\n            return (this.first === undefined && this.last === undefined)\r\n        }\r\n\r\n        /**\r\n         * Append given edge after the last edge (and before the first edge). <br/>\r\n         * This method mutates current object and does not return any value\r\n         * @param {PlanarSet} edges - Container of edges\r\n         * @param {Edge} edge - Edge to be appended to the linked list\r\n         */\r\n        append(edges, edge) {\r\n            if (this.first === undefined) {\r\n                edge.prev = edge;\r\n                edge.next = edge;\r\n                this.first = edge;\r\n                this.last = edge;\r\n                edge.arc_length = 0;\r\n            }\r\n            else {\r\n                // append to end\r\n                edge.prev = this.last;\r\n                this.last.next = edge;\r\n\r\n                // update edge to be last\r\n                this.last = edge;\r\n\r\n                // restore circular links\r\n                this.last.next = this.first;\r\n                this.first.prev = this.last;\r\n\r\n                // set arc length\r\n                edge.arc_length = edge.prev.arc_length + edge.prev.length;\r\n            }\r\n            edge.face = this;\r\n\r\n            edges.add(edge);      // Add new edges into edges container\r\n        }\r\n\r\n        /**\r\n         * Insert edge newEdge into the linked list after the edge edgeBefore <br/>\r\n         * This method mutates current object and does not return any value\r\n         * @param {PlanarSet} edges - Container of edges\r\n         * @param {Edge} newEdge - Edge to be inserted into linked list\r\n         * @param {Edge} edgeBefore - Edge to insert newEdge after it\r\n         */\r\n        insert(edges, newEdge, edgeBefore) {\r\n            if (this.first === undefined) {\r\n                newEdge.prev = newEdge;\r\n                newEdge.next = newEdge;\r\n                this.first = newEdge;\r\n                this.last = newEdge;\r\n            }\r\n            else {\r\n                /* set links to new edge */\r\n                let edgeAfter = edgeBefore.next;\r\n                edgeBefore.next = newEdge;\r\n                edgeAfter.prev = newEdge;\r\n\r\n                /* set links from new edge */\r\n                newEdge.prev = edgeBefore;\r\n                newEdge.next = edgeAfter;\r\n\r\n                /* extend chain if new edge added after last edge */\r\n                if (this.last === edgeBefore)\r\n                    this.first = newEdge;\r\n            }\r\n            newEdge.face = this;\r\n\r\n            // set arc length\r\n            if (newEdge.prev === this.last) {\r\n                newEdge.arc_length = 0;\r\n            }\r\n            else {\r\n                newEdge.arc_length = newEdge.prev.arc_length + newEdge.prev.length;\r\n            }\r\n\r\n            edges.add(newEdge);      // Add new edges into edges container\r\n        }\r\n\r\n        /**\r\n         * Remove the given edge from the linked list of the face <br/>\r\n         * This method mutates current object and does not return any value\r\n         * @param {PlanarSet} edges - Container of edges\r\n         * @param {Edge} edge - Edge to be removed\r\n         */\r\n        remove(edges, edge) {\r\n            // special case if last edge removed\r\n            if (edge === this.first && edge === this.last) {\r\n                this.first = undefined;\r\n                this.last = undefined;\r\n            }\r\n            else {\r\n                // update linked list\r\n                edge.prev.next = edge.next;\r\n                edge.next.prev = edge.prev;\r\n                // update first if need\r\n                if (edge === this.first) {\r\n                    this.first = edge.next;\r\n                }\r\n                // update last if need\r\n                if (edge === this.last) {\r\n                    this.last = edge.prev;\r\n                }\r\n            }\r\n            edges.delete(edge);      // delete from PlanarSet of edges and update index\r\n        }\r\n\r\n        /**\r\n         * Reverse orientation of the face: first edge become last and vice a verse,\r\n         * all edges starts and ends swapped, direction of arcs inverted.\r\n         */\r\n        reverse() {\r\n            // collect edges in revert order with reverted shapes\r\n            let edges = [];\r\n            let edge_tmp = this.last;\r\n            do {\r\n                // reverse shape\r\n                edge_tmp.shape = edge_tmp.shape.reverse();\r\n                edges.push(edge_tmp);\r\n                edge_tmp = edge_tmp.prev;\r\n            } while (edge_tmp !== this.last);\r\n\r\n            // restore linked list\r\n            this.first = undefined;\r\n            this.last = undefined;\r\n            for (let edge of edges) {\r\n                if (this.first === undefined) {\r\n                    edge.prev = edge;\r\n                    edge.next = edge;\r\n                    this.first = edge;\r\n                    this.last = edge;\r\n                    edge.arc_length = 0;\r\n                }\r\n                else {\r\n                    // append to end\r\n                    edge.prev = this.last;\r\n                    this.last.next = edge;\r\n\r\n                    // update edge to be last\r\n                    this.last = edge;\r\n\r\n                    // restore circular links\r\n                    this.last.next = this.first;\r\n                    this.first.prev = this.last;\r\n\r\n                    // set arc length\r\n                    edge.arc_length = edge.prev.arc_length + edge.prev.length;\r\n                }\r\n            }\r\n\r\n            // Recalculate orientation, if set\r\n            if (this._orientation !== undefined) {\r\n                this._orientation = undefined;\r\n                this._orientation = this.orientation();\r\n            }\r\n        }\r\n\r\n\r\n        /**\r\n         * Set arc_length property for each of the edges in the face.\r\n         * Arc_length of the edge it the arc length from the first edge of the face\r\n         */\r\n        setArcLength() {\r\n            for (let edge of this) {\r\n                if (edge === this.first) {\r\n                    edge.arc_length = 0.0;\r\n                }\r\n                else {\r\n                    edge.arc_length = edge.prev.arc_length + edge.prev.length;\r\n                }\r\n                edge.face = this;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns the absolute value of the area of the face\r\n         * @returns {number}\r\n         */\r\n        area() {\r\n            return Math.abs(this.signedArea());\r\n        }\r\n\r\n        /**\r\n         * Returns signed area of the simple face.\r\n         * Face is simple if it has no self intersections that change its orientation.\r\n         * Then the area will be positive if the orientation of the face is clockwise,\r\n         * and negative if orientation is counterclockwise.\r\n         * It may be zero if polygon is degenerated.\r\n         * @returns {number}\r\n         */\r\n        signedArea() {\r\n            let sArea = 0;\r\n            let ymin = this.box.ymin;\r\n            for (let edge of this) {\r\n                sArea += edge.shape.definiteIntegral(ymin);\r\n            }\r\n            return sArea;\r\n        }\r\n\r\n        /**\r\n         * Return face orientation: one of Flatten.ORIENTATION.CCW, Flatten.ORIENTATION.CW, Flatten.ORIENTATION.NOT_ORIENTABLE <br/>\r\n         * According to Green theorem the area of a closed curve may be calculated as double integral,\r\n         * and the sign of the integral will be defined by the direction of the curve.\r\n         * When the integral (\"signed area\") will be negative, direction is counter clockwise,\r\n         * when positive - clockwise and when it is zero, polygon is not orientable.\r\n         * See {@link https://mathinsight.org/greens_theorem_find_area}\r\n         * @returns {number}\r\n         */\r\n        orientation() {\r\n            if (this._orientation === undefined) {\r\n                let area = this.signedArea();\r\n                if (Flatten.Utils.EQ_0(area)) {\r\n                    this._orientation = Flatten.ORIENTATION.NOT_ORIENTABLE;\r\n                }\r\n                else if (Flatten.Utils.LT(area, 0)) {\r\n                    this._orientation = Flatten.ORIENTATION.CCW;\r\n                }\r\n                else {\r\n                    this._orientation = Flatten.ORIENTATION.CW;\r\n                }\r\n            }\r\n            return this._orientation;\r\n        }\r\n\r\n        /**\r\n         * Returns true if face of the polygon is simple (no self-intersection points found)\r\n         * NOTE: this method is incomplete because it doe not exclude touching points\r\n         * Real self intersection inverts orientation of the polygon.\r\n         * But this is also good enough for the demonstration of the idea\r\n         * @param {Edges} edges - reference to polygon.edges to provide search index\r\n         * @returns {boolean}\r\n         */\r\n        isSimple(edges) {\r\n            let ip = Face.getSelfIntersections(this, edges, true);\r\n            return ip.length == 0;\r\n        }\r\n\r\n        static getSelfIntersections(face, edges, exitOnFirst = false) {\r\n            let int_points = [];\r\n\r\n            // calculate intersections\r\n            for (let edge1 of face) {\r\n\r\n                // request edges of polygon in the box of edge1\r\n                let resp = edges.search(edge1.box);\r\n\r\n                // for each edge2 in response\r\n                for (let edge2 of resp) {\r\n\r\n                    // Skip itself\r\n                    if (edge1 === edge2)\r\n                        continue;\r\n\r\n                    // Skip next and previous edge if both are segment (if one of them arc - calc intersection)\r\n                    if (edge1.shape instanceof Flatten.Segment && edge2.shape instanceof Flatten.Segment &&\r\n                        (edge1.next === edge2 || edge1.prev === edge2))\r\n                        continue;\r\n\r\n                    // calculate intersections between edge1 and edge2\r\n                    let ip = edge1.shape.intersect(edge2.shape);\r\n\r\n                    // for each intersection point\r\n                    for (let pt of ip) {\r\n\r\n                        // skip start-end connections\r\n                        if (pt.equalTo(edge1.start) && pt.equalTo(edge2.end) && edge2 === edge1.prev)\r\n                            continue;\r\n                        if (pt.equalTo(edge1.end) && pt.equalTo(edge2.start) && edge2 === edge1.next)\r\n                            continue;\r\n\r\n                        int_points.push(pt);\r\n\r\n                        if (exitOnFirst)\r\n                            break;\r\n                    }\r\n\r\n                    if (int_points.length > 0 && exitOnFirst)\r\n                        break;\r\n                }\r\n\r\n                if (int_points.length > 0 && exitOnFirst)\r\n                    break;\r\n\r\n            }\r\n            return int_points;\r\n        }\r\n\r\n        toJSON() {\r\n            return this.edges.map(edge => edge.toJSON());\r\n        }\r\n\r\n        /**\r\n         * Returns string to be assigned to \"d\" attribute inside defined \"path\"\r\n         * @returns {string}\r\n         */\r\n        svg() {\r\n            let svgStr = `\\nM${this.first.start.x},${this.first.start.y}`;\r\n            for (let edge of this) {\r\n                svgStr += edge.svg();\r\n            }\r\n            svgStr += ` z`;\r\n            return svgStr;\r\n        }\r\n\r\n    };\r\n};","\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    let {Point, Segment, Line, Circle, Arc, Box, Vector} = Flatten;\r\n    /**\r\n     * Class representing a horizontal ray, used by ray shooting algorithm\r\n     * @type {Ray}\r\n     */\r\n    Flatten.Ray = class Ray {\r\n        /**\r\n         * Construct ray by setting start point\r\n         * @param {Point} pt - start point\r\n         */\r\n        constructor(...args) {\r\n            this.pt = new Point();\r\n\r\n            if (args.length == 0) {\r\n                return;\r\n            }\r\n\r\n            if (args.length == 1 && args[0] instanceof Point) {\r\n                this.pt = args[0].clone();\r\n                return;\r\n            }\r\n\r\n            if (args.length == 2 && typeof(args[0]) == \"number\" && typeof(args[1]) == \"number\") {\r\n                this.pt = new Point(args[0], args[1]);\r\n                return;\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Returns copied instance of the ray object\r\n         * @returns {Ray}\r\n         */\r\n        clone() {\r\n            return new Ray(this.pt);\r\n        }\r\n\r\n        /**\r\n         * Returns half-infinite bounding box of the ray\r\n         * @returns {Box} - bounding box\r\n         */\r\n        get box() {\r\n            return new Box(\r\n                this.pt.x,\r\n                this.pt.y,\r\n                Number.POSITIVE_INFINITY,\r\n                this.pt.y\r\n            )\r\n        }\r\n\r\n        /**\r\n         * Return ray start point\r\n         * @returns {Point} - ray start point\r\n         */\r\n        get start() {\r\n            return this.pt;\r\n        }\r\n\r\n        /**\r\n         * Return ray normal vector (0,1) - horizontal ray\r\n         * @returns {Vector} - ray normal vector\r\n         */\r\n        get norm() {\r\n            return new Vector(0,1);\r\n        }\r\n\r\n        /**\r\n         * Returns array of intersection points between ray and segment or arc\r\n         * @param {Segment|Arc} - Shape to intersect with ray\r\n         * @returns {Array} array of intersection points\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Segment) {\r\n                return this.intersectRay2Segment(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Arc) {\r\n                return this.intersectRay2Arc(this, shape);\r\n            }\r\n        }\r\n\r\n        intersectRay2Segment(ray, segment) {\r\n            let ip = [];\r\n\r\n            if (ray.box.not_intersect(segment.box)) {\r\n                return ip;\r\n            }\r\n\r\n            let line = new Line(ray.start, ray.norm);\r\n            let ip_tmp = line.intersect(segment);\r\n\r\n            for (let pt of ip_tmp) {\r\n                if (Flatten.Utils.GE(pt.x, ray.start.x)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n\r\n            /* If there were two intersection points between line and ray,\r\n            and now there is exactly one left, it means ray starts between these points\r\n            and there is another intersection point - start of the ray */\r\n            if (ip_tmp.length == 2 && ip.length == 1 && ray.start.on(line)) {\r\n                ip.push(ray.start);\r\n            }\r\n\r\n            return ip;\r\n        }\r\n\r\n        intersectRay2Arc(ray, arc) {\r\n            let ip = [];\r\n\r\n            if (ray.box.not_intersect(arc.box)) {\r\n                return ip;\r\n            }\r\n\r\n            let line = new Line(ray.start, ray.norm);\r\n            let ip_tmp = line.intersect(arc);\r\n\r\n            for (let pt of ip_tmp) {\r\n                if (Flatten.Utils.GE(pt.x, ray.start.x)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n            return ip;\r\n        }\r\n    };\r\n\r\n    Flatten.ray = (...args) => new Flatten.Ray(...args);\r\n};","\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    let {Polygon, Point, Segment, Arc, Line, Ray} = Flatten;\r\n\r\n    Flatten.ray_shoot = function(polygon, point) {\r\n        let contains = undefined;\r\n\r\n        // if (!(polygon instanceof Polygon && point instanceof Point)) {\r\n        //     throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        // }\r\n\r\n        // 1. Quick reject\r\n        if (polygon.box.not_intersect(point.box)) {\r\n            return Flatten.OUTSIDE;\r\n        }\r\n\r\n        let ray = new Ray(point);\r\n        let line = new Line(ray.pt, ray.norm);\r\n\r\n        // 2. Locate relevant edges of the polygon\r\n        let resp_edges = polygon.edges.search(ray.box);\r\n\r\n        if (resp_edges.length == 0) {\r\n            return Flatten.OUTSIDE;\r\n        }\r\n\r\n        // 3. Calculate intersections\r\n        let intersections = [];\r\n        for (let edge of resp_edges) {\r\n            for (let ip of ray.intersect(edge.shape)) {\r\n\r\n                // If intersection is equal to query point then point lays on boundary\r\n                if (ip.equalTo(point)) {\r\n                    return Flatten.BOUNDARY;\r\n                }\r\n\r\n                intersections.push({\r\n                    pt: ip,\r\n                    edge: edge\r\n                });\r\n            }\r\n        }\r\n\r\n        // 4. Sort intersection in x-ascending order\r\n        intersections.sort( (i1, i2) => {\r\n            if (Flatten.Utils.LT(i1.pt.x, i2.pt.x)) {\r\n                return -1;\r\n            }\r\n            if (Flatten.Utils.GT(i1.pt.x, i2.pt.x)) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        });\r\n\r\n        // 5. Count real intersections, exclude touching\r\n        let counter = 0;\r\n\r\n        for (let i=0; i < intersections.length; i++) {\r\n            let intersection = intersections[i];\r\n            if (intersection.pt.equalTo(intersection.edge.shape.start)) {\r\n                /* skip same point between same edges if already counted */\r\n                if (i > 0 && intersection.pt.equalTo(intersections[i-1].pt) &&\r\n                    intersection.edge.prev === intersections[i-1].edge) {\r\n                    continue;\r\n                }\r\n                let prev_edge = intersection.edge.prev;\r\n                while (Flatten.Utils.EQ_0(prev_edge.length)) {\r\n                    prev_edge = prev_edge.prev;\r\n                }\r\n                let prev_tangent = prev_edge.shape.tangentInEnd();\r\n                let prev_point = intersection.pt.translate(prev_tangent);\r\n\r\n                let cur_tangent = intersection.edge.shape.tangentInStart();\r\n                let cur_point = intersection.pt.translate(cur_tangent);\r\n\r\n                let prev_on_the_left = prev_point.leftTo(line);\r\n                let cur_on_the_left = cur_point.leftTo(line);\r\n\r\n                if ( (prev_on_the_left && !cur_on_the_left) || (!prev_on_the_left && cur_on_the_left) ) {\r\n                    counter++;\r\n                }\r\n            }\r\n            else if (intersection.pt.equalTo(intersection.edge.shape.end)) {\r\n                /* skip same point between same edges if already counted */\r\n                if (i > 0 && intersection.pt.equalTo(intersections[i-1].pt) &&\r\n                    intersection.edge.next === intersections[i-1].edge) {\r\n                    continue;\r\n                }\r\n                let next_edge = intersection.edge.next;\r\n                while (Flatten.Utils.EQ_0(next_edge.length)) {\r\n                    next_edge = next_edge.next;\r\n                }\r\n                let next_tangent = next_edge.shape.tangentInStart();\r\n                let next_point = intersection.pt.translate(next_tangent);\r\n\r\n                let cur_tangent = intersection.edge.shape.tangentInEnd();\r\n                let cur_point = intersection.pt.translate(cur_tangent);\r\n\r\n                let next_on_the_left = next_point.leftTo(line);\r\n                let cur_on_the_left = cur_point.leftTo(line);\r\n\r\n                if ( (next_on_the_left && !cur_on_the_left) || (!next_on_the_left && cur_on_the_left) ) {\r\n                    counter++;\r\n                }\r\n            }\r\n            else {        /* intersection point is not a coincident with a vertex */\r\n                if (intersection.edge.shape instanceof Segment) {\r\n                    counter++;\r\n                }\r\n                else {\r\n                    /* Check if ray does not touch the curve in the extremal (top or bottom) point */\r\n                    let box = intersection.edge.shape.box;\r\n                    if ( !(Flatten.Utils.EQ(intersection.pt.y, box.ymin) ||\r\n                            Flatten.Utils.EQ(intersection.pt.y, box.ymax)) ) {\r\n                        counter++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // 6. Odd or even?\r\n        contains = counter % 2 == 1 ? Flatten.INSIDE : Flatten.OUTSIDE;\r\n\r\n        return contains;\r\n    };\r\n};","/**\r\n * Created by Alex Bol on 3/15/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    let {Edge, Face, PlanarSet, Box} = Flatten;\r\n    let {ray_shoot} = Flatten;\r\n    /**\r\n     * Class representing a polygon.<br/>\r\n     * Polygon in FlattenJS is a multipolygon comprised from a set of [faces]{@link Flatten.Face}. <br/>\r\n     * Face, in turn, is a closed loop of [edges]{@link Flatten.Edge}, where edge may be segment or circular arc<br/>\r\n     * @type {Polygon}\r\n     */\r\n    Flatten.Polygon = class Polygon {\r\n        /**\r\n         * Constructor creates new instance of polygon.<br/>\r\n         * New polygon is empty. Add face to the polygon using method <br/>\r\n         * <code>\r\n         *     polygon.addFace(Points[]|Segments[]|Arcs[])\r\n         * </code>\r\n         */\r\n        constructor() {\r\n            /**\r\n             * Container of faces (closed loops), may be empty\r\n             * @type {PlanarSet}\r\n             */\r\n            this.faces = new PlanarSet();\r\n            /**\r\n             * Container of edges\r\n             * @type {PlanarSet}\r\n             */\r\n            this.edges = new PlanarSet();\r\n        }\r\n\r\n        /**\r\n         * (Getter) Returns bounding box of the polygon\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            return [...this.faces].reduce( (acc, face) => acc.merge(face.box), new Box() );\r\n        }\r\n\r\n        /**\r\n         * (Getter) Returns array of vertices\r\n         * @returns {Array}\r\n         */\r\n        get vertices() {\r\n            return [...this.edges].map( edge => edge.start);\r\n        }\r\n\r\n        /**\r\n         * Return true is polygon has no edges\r\n         * @returns {boolean}\r\n         */\r\n        isEmpty() {\r\n            return this.edges.size === 0;\r\n        }\r\n\r\n        /**\r\n         * Add new face to polygon. Returns added face\r\n         * @param {Points[]|Segments[]|Arcs[]|Circle|Box} args -  new face may be create with one of the following ways: <br/>\r\n         * 1) array of points that describe closed path (edges are segments) <br/>\r\n         * 2) array of shapes (segments and arcs) which describe closed path <br/>\r\n         * 3) circle - will be added as counterclockwise arc <br/>\r\n         * 4) box - will be added as counterclockwise rectangle <br/>\r\n         * You can chain method face.reverse() is you need to change direction of the creates face\r\n         * @returns {Face}\r\n         */\r\n        addFace(...args) {\r\n            let face = new Face(this, ...args);\r\n            this.faces.add(face);\r\n            return face;\r\n        }\r\n\r\n        /**\r\n         * Delete existing face from polygon\r\n         * @param {Face} face Face to be deleted\r\n         * @returns {boolean}\r\n         */\r\n        deleteFace(face) {\r\n            for (let edge of face) {\r\n                let deleted = this.edges.delete(edge);\r\n            }\r\n            let deleted = this.faces.delete(face);\r\n            return deleted;\r\n        }\r\n\r\n        /**\r\n         * Delete chain of edges from the face.\r\n         * @param {Face} face Face to remove chain\r\n         * @param {Edge} edgeFrom Start of the chain of edges to be removed\r\n         * @param {Edge} edgeTo End of the chain of edges to be removed\r\n         */\r\n        removeChain(face, edgeFrom, edgeTo) {\r\n            // Special case: all edges removed\r\n            if (edgeTo.next === edgeFrom) {\r\n                this.deleteFace(face);\r\n                return;\r\n            }\r\n            for (let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next ) {\r\n                face.remove(this.edges, edge);\r\n                // this.edges.delete(edge);      // delete from PlanarSet of edges and update index\r\n                if (face.isEmpty()) {\r\n                    this.deleteFace(face);    // delete from PlanarSet of faces and update index\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Add point as a new vertex and split edge. Point supposed to belong to an edge.\r\n         * When edge is split, new edge created from the start of the edge to the new vertex\r\n         * and inserted before current edge.\r\n         * Current edge is trimmed and updated. Method returns new edge added.\r\n         * @param {Edge} edge Edge to be split with new vertex and then trimmed from start\r\n         * @param {Point} pt Point to be added as a new vertex\r\n         * @returns {Edge}\r\n         */\r\n        addVertex(pt, edge) {\r\n            let shapes = edge.shape.split(pt);\r\n            if (shapes.length < 2) return;\r\n            let newEdge = new Flatten.Edge(shapes[0]);\r\n            let edgeBefore = edge.prev;\r\n\r\n            /* Insert first split edge into linked list after edgeBefore */\r\n            edge.face.insert(this.edges, newEdge, edgeBefore);\r\n\r\n            // Remove old edge from edges container and 2d index\r\n            this.edges.delete(edge);\r\n\r\n            // Update edge shape with second split edge keeping links\r\n            edge.shape = shapes[1];\r\n\r\n            // Add updated edge to the edges container and 2d index\r\n            this.edges.add(edge);\r\n\r\n            return newEdge;\r\n        }\r\n\r\n        reverse() {\r\n            for (let face of this.faces) {\r\n                face.reverse();\r\n            }\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Create new copied instance of the polygon\r\n         * @returns {Polygon}\r\n         */\r\n        clone() {\r\n            let polygon = new Polygon();\r\n            for (let face of this.faces) {\r\n                let shapes = [];\r\n                for (let edge of face) {\r\n                    shapes.push(edge.shape.clone());\r\n                }\r\n                polygon.addFace(shapes);\r\n            }\r\n            return polygon;\r\n        }\r\n\r\n        /**\r\n         * Returns area of the polygon. Area of an island will be added, area of a hole will be subtracted\r\n         * @returns {number}\r\n         */\r\n        area() {\r\n            let signedArea = [...this.faces].reduce((acc,face) => acc + face.signedArea(), 0);\r\n            return Math.abs(signedArea);\r\n        }\r\n\r\n        /**\r\n         * Returns true if polygon contains point, including polygon boundary, false otherwise\r\n         * Point in polygon test based on ray shooting algorithm\r\n         * @param {Point} point - test point\r\n         * @returns {boolean}\r\n         */\r\n        contains(point) {\r\n            let rel = ray_shoot(this, point);\r\n            return (rel == Flatten.INSIDE || rel == Flatten.BOUNDARY) ? true : false;\r\n        }\r\n\r\n        /**\r\n         * Return distance and shortest segment between polygon and other shape as array [distance, shortest_segment]\r\n         * @param {Shape} shape Shape of one of the types Point, Circle, Line, Segment, Arc or Polygon\r\n         * @returns {Number | Segment}\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n\r\n            if (shape instanceof Flatten.Point) {\r\n                let [dist, shortest_segment] = Distance.point2polygon(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle ||\r\n            shape instanceof Flatten.Line ||\r\n            shape instanceof Flatten.Segment ||\r\n            shape instanceof Flatten.Arc) {\r\n                let [dist, shortest_segment] = Distance.shape2polygon(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            /* this method is bit faster */\r\n            if (shape instanceof  Flatten.Polygon) {\r\n                let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n                let dist, shortest_segment;\r\n\r\n                for (let edge of this.edges) {\r\n                    // let [dist, shortest_segment] = Distance.shape2polygon(edge.shape, shape);\r\n                    let min_stop = min_dist_and_segment[0];\r\n                    [dist, shortest_segment] = Distance.shape2planarSet(edge.shape, shape.edges, min_stop);\r\n                    if (Flatten.Utils.LT(dist, min_stop)) {\r\n                        min_dist_and_segment = [dist, shortest_segment];\r\n                    }\r\n                }\r\n                return min_dist_and_segment;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Return array of intersection points between polygon and other shape\r\n         * @param shape Shape of the one of supported types <br/>\r\n         * @returns {Point[]}\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Flatten.Point) {\r\n                return this.contains(shape) ? [shape] : [];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                return Polygon.intersectLine2Polygon(shape, this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle ||\r\n                shape instanceof Flatten.Segment ||\r\n                shape instanceof Flatten.Arc) {\r\n                return Polygon.intersectShape2Polygon(shape, this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                return Polygon.intersectPolygon2Polygon(shape, this);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Return true if polygon is valid for boolean operations\r\n         * Polygon is valid if <br/>\r\n         * 1. All faces are simple polygons (there are no self-intersected polygons) <br/>\r\n         * 2. All faces are orientable and there is no island inside island or hole inside hole - TODO <br/>\r\n         * 3. There is no intersections between faces (excluding touching) - TODO <br/>\r\n         * @returns {boolean}\r\n         */\r\n        isValid() {\r\n            let valid = true;\r\n            // 1. Polygon is invalid if at least one face is not simple\r\n            for (let face of this.faces) {\r\n                if (!face.isSimple(this.edges)) {\r\n                    valid = false;\r\n                    break;\r\n                }\r\n            }\r\n            // 2. TODO: check if no island inside island and no hole inside hole\r\n            // 3. TODO: check the there is no intersection between faces\r\n            return valid;\r\n        }\r\n\r\n        /**\r\n         * Returns new polygon translated by vector vec\r\n         * @param {Vector} vec\r\n         * @returns {Polygon}\r\n         */\r\n        translate(vec) {\r\n            let newPolygon = new Polygon();\r\n            for (let face of this.faces) {\r\n                let shapes = [];\r\n                for (let edge of face) {\r\n                    shapes.push(edge.shape.translate(vec));\r\n                }\r\n                newPolygon.addFace(shapes);\r\n            }\r\n            return newPolygon;\r\n        }\r\n\r\n        /**\r\n         * Return new polygon rotated by given angle around given point\r\n         * If point omitted, rotate around origin (0,0)\r\n         * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n         * @param {number} angle - rotation angle in radians\r\n         * @param {Point} center - rotation center, default is (0,0)\r\n         * @returns {Polygon} - new rotated polygon\r\n         */\r\n        rotate(angle=0, center=new Flatten.Point()) {\r\n            let newPolygon = new Polygon();\r\n            for (let face of this.faces) {\r\n                let shapes = [];\r\n                for (let edge of face) {\r\n                    shapes.push(edge.shape.rotate(angle, center));\r\n                }\r\n                newPolygon.addFace(shapes);\r\n            }\r\n            return newPolygon;\r\n        }\r\n\r\n        /**\r\n         * Return new polygon transformed using affine transformation matrix\r\n         * @param {Matrix} matrix - affine transformation matrix\r\n         * @returns {Polygon} - new polygon\r\n         */\r\n        transform(matrix = new Flatten.Matrix()) {\r\n            let newPolygon = new Polygon();\r\n            for (let face of this.faces) {\r\n                let shapes = [];\r\n                for (let edge of face) {\r\n                    shapes.push(edge.shape.transform(matrix));\r\n                }\r\n                newPolygon.addFace(shapes);\r\n            }\r\n            return newPolygon;\r\n        }\r\n\r\n        static intersectShape2Polygon(shape, polygon) {\r\n            let ip = [];\r\n\r\n            if ( polygon.isEmpty() || shape.box.not_intersect(polygon.box) ) {\r\n                return ip;\r\n            }\r\n\r\n            let resp_edges = polygon.edges.search(shape.box);\r\n\r\n            for (let edge of resp_edges) {\r\n                for (let pt of shape.intersect(edge.shape)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n\r\n            return ip;\r\n        }\r\n\r\n        static intersectLine2Polygon(line, polygon) {\r\n            let ip = [];\r\n\r\n            if ( polygon.isEmpty() ) {\r\n                return ip;\r\n            }\r\n\r\n            for (let edge of polygon.edges) {\r\n                for (let pt of line.intersect(edge.shape)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n\r\n            return ip;\r\n        }\r\n\r\n        static intersectPolygon2Polygon(polygon1, polygon2) {\r\n            let ip = [];\r\n\r\n            if (polygon1.isEmpty() || polygon2.isEmpty()) {\r\n                return ip;\r\n            }\r\n\r\n            if (polygon1.box.not_intersect(polygon2.box)) {\r\n                return ip;\r\n            }\r\n\r\n            for (let edge1 of polygon1.edges) {\r\n                for (let pt of Polygon.intersectShape2Polygon(edge1.shape, polygon2)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n\r\n            return ip;\r\n        }\r\n\r\n        /**\r\n         * Return string to draw polygon in svg\r\n         * @param attrs  - an object with attributes for svg path element,\r\n         * like \"stroke\", \"strokeWidth\", \"fill\", \"fillRule\", \"fillOpacity\"\r\n         * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"lightcyan\", fillRule:\"evenodd\", fillOpacity: \"1\"\r\n         * @returns {string}\r\n         */\r\n        svg(attrs = {}) {\r\n            let {stroke, strokeWidth, fill, fillRule, fillOpacity, id, className} = attrs;\r\n            // let restStr = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n            let svgStr = `\\n<path stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"lightcyan\"}\" fill-rule=\"${fillRule || \"evenodd\"}\" fill-opacity=\"${fillOpacity || 1.0}\" ${id_str} ${class_str} d=\"`;\r\n            for (let face of this.faces) {\r\n                svgStr += face.svg();\r\n            }\r\n            svgStr += `\" >\\n</path>`;\r\n            return svgStr;\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return [...this.faces].map(face => face.toJSON());\r\n        }\r\n    }\r\n};","\"use strict\";\r\n\r\nlet IntervalTree = require('flatten-interval-tree');\r\n\r\nmodule.exports = function(Flatten) {\r\n    let {Polygon, Point, Segment, Arc, Circle, Line, Ray, Vector} = Flatten;\r\n\r\n    let {vector} = Flatten;\r\n\r\n    Flatten.Distance = class Distance {\r\n        /**\r\n         * Calculate distance and shortest segment between points\r\n         * @param pt1\r\n         * @param pt2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2point(pt1, pt2) {\r\n            return pt1.distanceTo(pt2);\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between point and line\r\n         * @param pt\r\n         * @param line\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2line(pt, line) {\r\n            let closest_point = pt.projectionOn(line);\r\n            let vec = vector(pt, closest_point);\r\n            return [vec.length, new Segment(pt, closest_point)];\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between point and circle\r\n         * @param pt\r\n         * @param circle\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2circle(pt, circle) {\r\n            let [dist2center, shortest_dist] = pt.distanceTo(circle.center);\r\n            if (Flatten.Utils.EQ_0(dist2center)) {\r\n                return [circle.r, new Segment(pt, circle.toArc().start)];\r\n            }\r\n            else {\r\n                let dist = Math.abs(dist2center - circle.r);\r\n                let v = vector(circle.pc, pt).normalize().multiply(circle.r);\r\n                let closest_point = circle.pc.translate(v);\r\n                return [dist, new Segment(pt, closest_point)];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between point and segment\r\n         * @param pt\r\n         * @param segment\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2segment(pt, segment) {\r\n            /* Degenerated case of zero-length segment */\r\n            if (segment.start.equalTo(segment.end)) {\r\n                return  Distance.point2point(pt, segment.start);\r\n            }\r\n\r\n            let v_seg = new Flatten.Vector(segment.start, segment.end);\r\n            let v_ps2pt = new Flatten.Vector(segment.start, pt);\r\n            let v_pe2pt = new Flatten.Vector(segment.end, pt);\r\n            let start_sp = v_seg.dot(v_ps2pt);\r\n            /* dot product v_seg * v_ps2pt */\r\n            let end_sp = -v_seg.dot(v_pe2pt);\r\n            /* minus dot product v_seg * v_pe2pt */\r\n\r\n            let dist;\r\n            let closest_point;\r\n            if (Flatten.Utils.GE(start_sp, 0) && Flatten.Utils.GE(end_sp, 0)) {    /* point inside segment scope */\r\n                let v_unit = segment.tangentInStart(); // new Flatten.Vector(v_seg.x / this.length, v_seg.y / this.length);\r\n                /* unit vector ||v_unit|| = 1 */\r\n                dist = Math.abs(v_unit.cross(v_ps2pt));\r\n                /* dist = abs(v_unit x v_ps2pt) */\r\n                closest_point = segment.start.translate(v_unit.multiply(v_unit.dot(v_ps2pt)));\r\n                return [dist, new Segment(pt, closest_point)];\r\n            }\r\n            else if (start_sp < 0) {                             /* point is out of scope closer to ps */\r\n                return pt.distanceTo(segment.start);\r\n            }\r\n            else {                                               /* point is out of scope closer to pe */\r\n                return pt.distanceTo(segment.end);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between point and arc\r\n         * @param pt\r\n         * @param arc\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2arc(pt, arc) {\r\n            let circle = new Flatten.Circle(arc.pc, arc.r);\r\n            let dist_and_segment = [];\r\n            let dist, shortest_segment;\r\n            [dist, shortest_segment] = Distance.point2circle(pt, circle);\r\n            if (shortest_segment.end.on(arc)) {\r\n                dist_and_segment.push(Distance.point2circle(pt, circle));\r\n            }\r\n            dist_and_segment.push( Distance.point2point(pt, arc.start) );\r\n            dist_and_segment.push( Distance.point2point(pt, arc.end) );\r\n\r\n            Distance.sort(dist_and_segment);\r\n\r\n            return dist_and_segment[0];\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between segment and line\r\n         * @param seg\r\n         * @param line\r\n         * @returns {Number | Segment}\r\n         */\r\n        static segment2line(seg, line) {\r\n            let ip = seg.intersect(line);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0],ip[0])];   // distance = 0, closest point is the first point\r\n            }\r\n            let dist_and_segment = [];\r\n            dist_and_segment.push(Distance.point2line(seg.start, line));\r\n            dist_and_segment.push(Distance.point2line(seg.end, line));\r\n\r\n            Distance.sort( dist_and_segment );\r\n            return dist_and_segment[0];\r\n\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between two segments\r\n         * @param seg1\r\n         * @param seg2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static segment2segment(seg1, seg2) {\r\n            let ip = Segment.intersectSegment2Segment(seg1, seg2);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0],ip[0])];   // distance = 0, closest point is the first point\r\n            }\r\n\r\n            // Seg1 and seg2 not intersected\r\n            let dist_and_segment = [];\r\n\r\n            dist_and_segment.push(Distance.point2segment(seg2.start, seg1));\r\n            dist_and_segment.push(Distance.point2segment(seg2.end, seg1));\r\n            dist_and_segment.push(Distance.point2segment(seg1.start, seg2));\r\n            dist_and_segment.push(Distance.point2segment(seg1.end, seg2));\r\n\r\n            Distance.sort( dist_and_segment );\r\n            return dist_and_segment[0];\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between segment and circle\r\n         * @param seg\r\n         * @param circle\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static segment2circle(seg, circle) {\r\n            /* Case 1 Segment and circle intersected. Return the first point and zero distance */\r\n            let ip = seg.intersect(circle);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            // No intersection between segment and circle\r\n\r\n            /* Case 2. Distance to projection of center point to line bigger than radius\r\n             * And projection point belong to segment\r\n              * Then measure again distance from projection to circle and return it */\r\n            let line = new Flatten.Line(seg.ps, seg.pe);\r\n            let [dist, shortest_segment] = Distance.point2line(circle.center, line);\r\n            if (Flatten.Utils.GE(dist, circle.r) && shortest_segment.end.on(seg)) {\r\n                return Distance.point2circle(shortest_segment.end, circle);\r\n            }\r\n            /* Case 3. Otherwise closest point is one of the end points of the segment */\r\n            else {\r\n                let [dist_from_start, shortest_segment_from_start] = Distance.point2circle(seg.start, circle);\r\n                let [dist_from_end, shortest_segment_from_end] = Distance.point2circle(seg.end, circle);\r\n                return Flatten.Utils.LT(dist_from_start, dist_from_end) ?\r\n                    [dist_from_start, shortest_segment_from_start] :\r\n                    [dist_from_end, shortest_segment_from_end];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between segment and arc\r\n         * @param seg\r\n         * @param arc\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static segment2arc(seg, arc) {\r\n            /* Case 1 Segment and arc intersected. Return the first point and zero distance */\r\n            let ip = seg.intersect(arc);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            // No intersection between segment and arc\r\n            let line = new Flatten.Line(seg.ps, seg.pe);\r\n            let circle = new Flatten.Circle(arc.pc, arc.r);\r\n\r\n            /* Case 2. Distance to projection of center point to line bigger than radius AND\r\n             * projection point belongs to segment AND\r\n               * distance from projection point to circle belongs to arc  =>\r\n               * return this distance from projection to circle */\r\n            let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n            if (Flatten.Utils.GE(dist_from_center, circle.r) && shortest_segment_from_center.end.on(seg)) {\r\n                let [dist_from_projection, shortest_segment_from_projection] =\r\n                    Distance.point2circle(shortest_segment_from_center.end, circle);\r\n                if (shortest_segment_from_projection.end.on(arc)) {\r\n                    return [dist_from_projection, shortest_segment_from_projection];\r\n                }\r\n            }\r\n            /* Case 3. Otherwise closest point is one of the end points of the segment */\r\n            let dist_and_segment = [];\r\n            dist_and_segment.push(Distance.point2arc(seg.start, arc));\r\n            dist_and_segment.push(Distance.point2arc(seg.end, arc));\r\n\r\n            let dist_tmp, segment_tmp;\r\n            [dist_tmp, segment_tmp] = Distance.point2segment(arc.start, seg);\r\n            dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2segment(arc.end, seg);\r\n            dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n\r\n            Distance.sort(dist_and_segment);\r\n            return dist_and_segment[0];\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between two circles\r\n         * @param circle1\r\n         * @param circle2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static circle2circle(circle1, circle2) {\r\n            let ip = circle1.intersect(circle2);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            // Case 1. Concentric circles. Convert to arcs and take distance between two arc starts\r\n            if (circle1.center.equalTo(circle2.center)) {\r\n                let arc1 = circle1.toArc();\r\n                let arc2 = circle2.toArc();\r\n                return Distance.point2point(arc1.start, arc2.start);\r\n            }\r\n            else {\r\n                // Case 2. Not concentric circles\r\n                let line = new Line(circle1.center, circle2.center);\r\n                let ip1 = line.intersect(circle1);\r\n                let ip2 = line.intersect(circle2);\r\n\r\n                let dist_and_segment = [];\r\n\r\n                dist_and_segment.push(Distance.point2point(ip1[0], ip2[0]));\r\n                dist_and_segment.push(Distance.point2point(ip1[0], ip2[1]));\r\n                dist_and_segment.push(Distance.point2point(ip1[1], ip2[0]));\r\n                dist_and_segment.push(Distance.point2point(ip1[1], ip2[1]));\r\n\r\n                Distance.sort(dist_and_segment);\r\n                return dist_and_segment[0];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between two circles\r\n         * @param circle\r\n         * @param line\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static circle2line(circle, line) {\r\n            let ip = circle.intersect(line);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n            let [dist, shortest_segment] = Distance.point2circle(shortest_segment_from_center.end, circle);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between arc and line\r\n         * @param arc\r\n         * @param line\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static arc2line(arc, line) {\r\n            /* Case 1 Line and arc intersected. Return the first point and zero distance */\r\n            let ip = line.intersect(arc);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let circle = new Flatten.Circle(arc.center, arc.r);\r\n\r\n            /* Case 2. Distance to projection of center point to line bigger than radius AND\r\n             * projection point belongs to segment AND\r\n               * distance from projection point to circle belongs to arc  =>\r\n               * return this distance from projection to circle */\r\n            let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n            if (Flatten.Utils.GE(dist_from_center, circle.r)) {\r\n                let [dist_from_projection, shortest_segment_from_projection] =\r\n                    Distance.point2circle(shortest_segment_from_center.end, circle);\r\n                if (shortest_segment_from_projection.end.on(arc)) {\r\n                    return [dist_from_projection, shortest_segment_from_projection];\r\n                }\r\n            }\r\n            else {\r\n                let dist_and_segment = [];\r\n                dist_and_segment.push( Distance.point2line(arc.start, line) );\r\n                dist_and_segment.push( Distance.point2line(arc.end, line) );\r\n\r\n                Distance.sort(dist_and_segment);\r\n                return dist_and_segment[0];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between arc and circle\r\n         * @param arc\r\n         * @param circle2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static arc2circle(arc, circle2) {\r\n            let ip = arc.intersect(circle2);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let circle1 = new Flatten.Circle(arc.center, arc.r);\r\n\r\n            let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\r\n            if (shortest_segment.start.on(arc)) {\r\n                return [dist, shortest_segment];\r\n            }\r\n            else {\r\n                let dist_and_segment = [];\r\n\r\n                dist_and_segment.push(Distance.point2circle(arc.start, circle2));\r\n                dist_and_segment.push(Distance.point2circle(arc.end, circle2));\r\n\r\n                Distance.sort(dist_and_segment);\r\n\r\n                return dist_and_segment[0];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between two arcs\r\n         * @param arc1\r\n         * @param arc2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static arc2arc(arc1, arc2) {\r\n            let ip = arc1.intersect(arc2);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let circle1 = new Flatten.Circle(arc1.center, arc1.r);\r\n            let circle2 = new Flatten.Circle(arc2.center, arc2.r);\r\n\r\n            let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\r\n            if (shortest_segment.start.on(arc1) && shortest_segment.end.on(arc2)) {\r\n                return [dist, shortest_segment];\r\n            }\r\n            else {\r\n                let dist_and_segment = [];\r\n\r\n                let dist_tmp, segment_tmp;\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2arc(arc1.start, arc2);\r\n                if (segment_tmp.end.on(arc2)) {\r\n                    dist_and_segment.push([dist_tmp, segment_tmp]);\r\n                }\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2arc(arc1.end, arc2);\r\n                if (segment_tmp.end.on(arc2)) {\r\n                    dist_and_segment.push([dist_tmp, segment_tmp]);\r\n                }\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2arc(arc2.start, arc1);\r\n                if (segment_tmp.end.on(arc1)) {\r\n                    dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n                }\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2arc(arc2.end, arc1);\r\n                if (segment_tmp.end.on(arc1)) {\r\n                    dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n                }\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.start);\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.end);\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.start);\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.end);\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n                Distance.sort(dist_and_segment);\r\n\r\n                return dist_and_segment[0];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between point and polygon\r\n         * @param point\r\n         * @param polygon\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2polygon(point, polygon) {\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\r\n            for (let edge of polygon.edges) {\r\n                let [dist, shortest_segment] = (edge.shape instanceof Segment) ?\r\n                    Distance.point2segment(point, edge.shape) : Distance.point2arc(point, edge.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n        static shape2polygon(shape, polygon) {\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\r\n            for (let edge of polygon.edges) {\r\n                let [dist, shortest_segment] = shape.distanceTo(edge.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n/*\r\n        static arc2polygon(arc, polygon) {\r\n            let ip = arc.intersect(polygon);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\r\n            for (let edge of polygon.edges) {\r\n                let [dist, shortest_segment] = arc.distanceTo(edge.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n        static line2polygon(line, polygon) {\r\n            let ip = line.intersect(polygon);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\r\n            for (let edge of polygon.edges) {\r\n                let [dist, shortest_segment] = line.distanceTo(edge.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n        static circle2polygon(circle, polygon) {\r\n            let ip = circle.intersect(polygon);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\r\n            for (let edge of polygon.edges) {\r\n                let [dist, shortest_segment] = circle.distanceTo(edge.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n*/\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between two polygons\r\n         * @param polygon1\r\n         * @param polygon2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static polygon2polygon(polygon1, polygon2) {\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n            for (let edge1 of polygon1.edges) {\r\n                for (let edge2 of polygon2.edges) {\r\n                    let [dist, shortest_segment] = edge1.shape.distanceTo(edge2.shape);\r\n                    if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                        min_dist_and_segment = [dist, shortest_segment];\r\n                    }\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n        /**\r\n         * Returns [mindist, maxdist] array of squared minimal and maximal distance between boxes\r\n         * Minimal distance by x is\r\n         *    (box2.xmin - box1.xmax), if box1 is left to box2\r\n         *    (box1.xmin - box2.xmax), if box2 is left to box1\r\n         *    0,                       if box1 and box2 are intersected by x\r\n         * Minimal distance by y is defined in the same way\r\n         *\r\n         * Maximal distance is estimated as a sum of squared dimensions of the merged box\r\n         *\r\n         * @param box1\r\n         * @param box2\r\n         * @returns {Number | Number} - minimal and maximal distance\r\n         */\r\n        static box2box_minmax(box1, box2) {\r\n            let mindist_x = Math.max( Math.max(box1.xmin - box2.xmax, 0), Math.max(box2.xmin - box1.xmax, 0) );\r\n            let mindist_y = Math.max( Math.max(box1.ymin - box2.ymax, 0), Math.max(box2.ymin - box1.ymax, 0) );\r\n            let mindist = mindist_x*mindist_x + mindist_y*mindist_y;\r\n\r\n            let box = box1.merge(box2);\r\n            let dx = box.xmax - box.xmin;\r\n            let dy = box.ymax - box.ymin;\r\n            let maxdist = dx*dx + dy*dy;\r\n\r\n            return [mindist, maxdist];\r\n        }\r\n\r\n        static minmax_tree_process_level(shape, level, min_stop, tree) {\r\n            // Calculate minmax distance to each shape in current level\r\n            // Insert result into the interval tree for further processing\r\n            // update min_stop with maxdist, it will be the new stop distance\r\n            let mindist, maxdist;\r\n            for (let node of level) {\r\n\r\n                // [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\r\n                // if (Flatten.Utils.GT(mindist, min_stop))\r\n                //     continue;\r\n\r\n                // Estimate min-max dist to the shape stored in the node.item, using node.item.key which is shape's box\r\n                [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.item.key);\r\n                if (node.item.value instanceof Flatten.Edge) {\r\n                    tree.insert([mindist, maxdist], node.item.value.shape);\r\n                }\r\n                else {\r\n                    tree.insert([mindist, maxdist], node.item.value);\r\n                }\r\n                if (Flatten.Utils.LT(maxdist, min_stop)) {\r\n                    min_stop = maxdist;                       // this will be the new distance estimation\r\n                }\r\n            }\r\n\r\n            if (level.length === 0)\r\n                return min_stop;\r\n\r\n            // Calculate new level from left and right children of the current\r\n            let new_level_left = level.map(node => node.left.isNil() ? undefined : node.left ).filter(node => node !== undefined);\r\n            let new_level_right = level.map(node => node.right.isNil() ? undefined : node.right).filter(node => node !== undefined);\r\n            // Merge left and right subtrees and leave only relevant subtrees\r\n            let new_level = [...new_level_left, ...new_level_right].filter( node => {\r\n                // Node subtree quick reject, node.max is a subtree box\r\n                let [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\r\n                return (Flatten.Utils.LE(mindist, min_stop));\r\n            });\r\n\r\n            min_stop = Distance.minmax_tree_process_level(shape, new_level, min_stop, tree);\r\n            return min_stop;\r\n        }\r\n\r\n        /**\r\n         * Calculates sorted tree of [mindist, maxdist] intervals between query shape\r\n         * and shapes of the planar set.\r\n         * @param shape\r\n         * @param set\r\n         */\r\n        static minmax_tree(shape, set, min_stop) {\r\n            let tree = new IntervalTree();\r\n            let level = [set.index.root];\r\n            let squared_min_stop = min_stop < Number.POSITIVE_INFINITY ? min_stop*min_stop : Number.POSITIVE_INFINITY;\r\n            squared_min_stop = Distance.minmax_tree_process_level(shape, level, squared_min_stop, tree);\r\n            return tree;\r\n        }\r\n\r\n        static minmax_tree_calc_distance(shape, node, min_dist_and_segment) {\r\n            let min_dist_and_segment_new, stop;\r\n            if (node != null && !node.isNil()) {\r\n                [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.left, min_dist_and_segment);\r\n\r\n                if (stop) {\r\n                    return [min_dist_and_segment_new, stop];\r\n                }\r\n\r\n                if (Flatten.Utils.LT(min_dist_and_segment_new[0], Math.sqrt(node.item.key.low))) {\r\n                    return [min_dist_and_segment_new, true];   // stop condition\r\n                }\r\n\r\n                let [dist, shortest_segment] = Distance.distance(shape, node.item.value);\r\n                // console.log(dist)\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment_new[0])) {\r\n                    min_dist_and_segment_new = [dist, shortest_segment];\r\n                }\r\n\r\n                [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.right, min_dist_and_segment_new);\r\n\r\n                return [min_dist_and_segment_new, stop];\r\n            }\r\n\r\n            return [min_dist_and_segment, false];\r\n        }\r\n\r\n        /**\r\n         * Calculates distance between shape and Planar Set of shapes\r\n         * @param shape\r\n         * @param {PlanarSet} set\r\n         * @param {Number} min_stop\r\n         * @returns {*}\r\n         */\r\n        static shape2planarSet(shape, set, min_stop = Number.POSITIVE_INFINITY) {\r\n            let min_dist_and_segment = [min_stop, new Flatten.Segment()];\r\n            let stop = false;\r\n            if (set instanceof Flatten.PlanarSet) {\r\n                let tree = Distance.minmax_tree(shape, set, min_stop);\r\n                [min_dist_and_segment, stop] = Distance.minmax_tree_calc_distance(shape, tree.root, min_dist_and_segment);\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n        static sort(dist_and_segment) {\r\n            dist_and_segment.sort((d1, d2) => {\r\n                if (Flatten.Utils.LT(d1[0], d2[0])) {\r\n                    return -1;\r\n                }\r\n                if (Flatten.Utils.GT(d1[0], d2[0])) {\r\n                    return 1;\r\n                }\r\n                return 0;\r\n            });\r\n        }\r\n\r\n        static distance(shape1, shape2) {\r\n            return shape1.distanceTo(shape2);\r\n        }\r\n    }\r\n};"],"sourceRoot":""}