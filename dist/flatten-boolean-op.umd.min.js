!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports["flatten-boolean-op"]=e():t["flatten-boolean-op"]=e()}(window,function(){return function(t){var e={};function i(n){if(e[n])return e[n].exports;var r=e[n]={i:n,l:!1,exports:{}};return t[n].call(r.exports,r,r.exports,i),r.l=!0,r.exports}return i.m=t,i.c=e,i.d=function(t,e,n){i.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:n})},i.r=function(t){Object.defineProperty(t,"__esModule",{value:!0})},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,"a",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p="",i(i.s=21)}([function(t,e,i){"use strict";t.exports={RB_TREE_COLOR_RED:0,RB_TREE_COLOR_BLACK:1}},function(t,e,i){"use strict";let n=i(16),{RB_TREE_COLOR_RED:r,RB_TREE_COLOR_BLACK:s}=i(0),o=new n;t.exports=class{constructor(){this.root=null}get size(){let t=0;return this.tree_walk(this.root,()=>t++),t}get keys(){let t=[];return this.tree_walk(this.root,e=>t.push(e.item.key.output())),t}get isEmpty(){return null==this.root||this.root==o}insert(t,e=t){if(void 0===t)return;let i=new n(t,e,o,o,null,r);return this.tree_insert(i),this.recalc_max(i),i}exist(t,e){let i=new n(t,e);return!!this.tree_search(this.root,i)}remove(t,e){let i=new n(t,e),r=this.tree_search(this.root,i);return r&&this.tree_delete(r),r}search(t){let e=new n(t),i=[];this.tree_search_interval(this.root,e,i);let r=[];return i.forEach(t=>{t.item.value?r.push(t.item.value):r.push(t.item.key.output())},[]),r}forEach(t){this.tree_walk(this.root,e=>t(e.item.key,e.item.value))}recalc_max(t){let e=t;for(;null!=e.parent;)e.parent.update_max(),e=e.parent}tree_insert(t){let e=this.root,i=null;if(null==this.root||this.root==o)this.root=t;else{for(;e!=o;)i=e,e=t.less_than(e)?e.left:e.right;t.parent=i,t.less_than(i)?i.left=t:i.right=t}this.insert_fixup(t)}insert_fixup(t){let e,i;for(e=t;e!=this.root&&e.parent.color==r;)e.parent==e.parent.parent.left?(i=e.parent.parent.right).color==r?(e.parent.color=s,i.color=s,e.parent.parent.color=r,e=e.parent.parent):(e==e.parent.right&&(e=e.parent,this.rotate_left(e)),e.parent.color=s,e.parent.parent.color=r,this.rotate_right(e.parent.parent)):(i=e.parent.parent.left).color==r?(e.parent.color=s,i.color=s,e.parent.parent.color=r,e=e.parent.parent):(e==e.parent.left&&(e=e.parent,this.rotate_right(e)),e.parent.color=s,e.parent.parent.color=r,this.rotate_left(e.parent.parent));this.root.color=s}tree_delete(t){let e,i;(i=(e=t.left==o||t.right==o?t:this.tree_successor(t)).left!=o?e.left:e.right).parent=e.parent,e==this.root?this.root=i:(e==e.parent.left?e.parent.left=i:e.parent.right=i,e.parent.update_max()),this.recalc_max(i),e!=t&&(t.copy_data(e),t.update_max(),this.recalc_max(t)),e.color==s&&this.delete_fixup(i)}delete_fixup(t){let e,i=t;for(;i!=this.root&&null!=i.parent&&i.color==s;)i==i.parent.left?((e=i.parent.right).color==r&&(e.color=s,i.parent.color=r,this.rotate_left(i.parent),e=i.parent.right),e.left.color==s&&e.right.color==s?(e.color=r,i=i.parent):(e.right.color==s&&(e.color=r,e.left.color=s,this.rotate_right(e),e=i.parent.right),e.color=i.parent.color,i.parent.color=s,e.right.color=s,this.rotate_left(i.parent),i=this.root)):((e=i.parent.left).color==r&&(e.color=s,i.parent.color=r,this.rotate_right(i.parent),e=i.parent.left),e.left.color==s&&e.right.color==s?(e.color=r,i=i.parent):(e.left.color==s&&(e.color=r,e.right.color=s,this.rotate_left(e),e=i.parent.left),e.color=i.parent.color,i.parent.color=s,e.left.color=s,this.rotate_right(i.parent),i=this.root));i.color=s}tree_search(t,e){if(null!=t&&t!=o)return e.equal_to(t)?t:e.less_than(t)?this.tree_search(t.left,e):this.tree_search(t.right,e)}tree_search_interval(t,e,i){null!=t&&t!=o&&(t.left==o||t.not_intersect_left_subtree(e)||this.tree_search_interval(t.left,e,i),t.intersect(e)&&i.push(t),t.right==o||t.not_intersect_right_subtree(e)||this.tree_search_interval(t.right,e,i))}local_minimum(t){let e=t;for(;null!=e.left&&e.left!=o;)e=e.left;return e}local_maximum(t){let e=t;for(;null!=e.right&&e.right!=o;)e=e.right;return e}tree_successor(t){let e,i,n;if(t.right!=o)e=this.local_minimum(t.right);else{for(i=t,n=t.parent;null!=n&&n.right==i;)i=n,n=n.parent;e=n}return e}rotate_left(t){let e=t.right;t.right=e.left,e.left!=o&&(e.left.parent=t),e.parent=t.parent,t==this.root?this.root=e:t==t.parent.left?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e,null!=t&&t!=o&&t.update_max(),null!=(e=t.parent)&&e!=o&&e.update_max()}rotate_right(t){let e=t.left;t.left=e.right,e.right!=o&&(e.right.parent=t),e.parent=t.parent,t==this.root?this.root=e:t==t.parent.left?t.parent.left=e:t.parent.right=e,e.right=t,t.parent=e,null!=t&&t!=o&&t.update_max(),null!=(e=t.parent)&&e!=o&&e.update_max()}tree_walk(t,e){null!=t&&t!=o&&(this.tree_walk(t.left,e),e(t),this.tree_walk(t.right,e))}testRedBlackProperty(){let t=!0;return this.tree_walk(this.root,function(e){e.color==r&&(e.left.color==s&&e.right.color==s||(t=!1))}),t}testBlackHeightProperty(t){let e=0,i=0,n=0;if(t.color==s&&e++,(i=t.left!=o?this.testBlackHeightProperty(t.left):1)!=(n=t.right!=o?this.testBlackHeightProperty(t.right):1))throw new Error("Red-black height property violated");return e+=i}}},function(t,e,i){"use strict";let n=i(1);t.exports=function(t){let{Polygon:e,Point:i,Segment:r,Arc:s,Circle:o,Line:l,Ray:a,Vector:h}=t,{vector:c}=t;t.Distance=class e{static point2point(t,e){return t.distanceTo(e)}static point2line(t,e){let i=t.projectionOn(e);return[c(t,i).length,new r(t,i)]}static point2circle(e,i){let[n,s]=e.distanceTo(i.center);if(t.Utils.EQ_0(n))return[i.r,new r(e,i.toArc().start)];{let t=Math.abs(n-i.r),s=c(i.pc,e).normalize().multiply(i.r),o=i.pc.translate(s);return[t,new r(e,o)]}}static point2segment(i,n){if(n.start.equalTo(n.end))return e.point2point(i,n.start);let s,o,l=new t.Vector(n.start,n.end),a=new t.Vector(n.start,i),h=new t.Vector(n.end,i),c=l.dot(a),f=-l.dot(h);if(t.Utils.GE(c,0)&&t.Utils.GE(f,0)){let t=n.tangentInStart();return s=Math.abs(t.cross(a)),o=n.start.translate(t.multiply(t.dot(a))),[s,new r(i,o)]}return c<0?i.distanceTo(n.start):i.distanceTo(n.end)}static point2arc(i,n){let r,s,o=new t.Circle(n.pc,n.r),l=[];return[r,s]=e.point2circle(i,o),s.end.on(n)&&l.push(e.point2circle(i,o)),l.push(e.point2point(i,n.start)),l.push(e.point2point(i,n.end)),e.sort(l),l[0]}static segment2line(t,i){let n=t.intersect(i);return n.length>0?[0,new r(n[0],n[0])]:(dist_and_segment.push(e.point2line(t.start,i)),dist_and_segment.push(e.point2line(t.end,i)),e.sort(dist_and_segment),dist_and_segment[0])}static segment2segment(t,i){let n=r.intersectSegment2Segment(t,i);if(n.length>0)return[0,new r(n[0],n[0])];let s=[];return s.push(e.point2segment(i.start,t)),s.push(e.point2segment(i.end,t)),s.push(e.point2segment(t.start,i)),s.push(e.point2segment(t.end,i)),e.sort(s),s[0]}static segment2circle(i,n){let s=i.intersect(n);if(s.length>0)return[0,new r(s[0],s[0])];let o=new t.Line(i.ps,i.pe),[l,a]=e.point2line(n.center,o);if(t.Utils.GE(l,n.r)&&a.end.on(i))return e.point2circle(a.end,n);{let[r,s]=e.point2circle(i.start,n),[o,l]=e.point2circle(i.end,n);return t.Utils.LT(r,o)?[r,s]:[o,l]}}static segment2arc(i,n){let s=i.intersect(n);if(s.length>0)return[0,new r(s[0],s[0])];let o=new t.Line(i.ps,i.pe),l=new t.Circle(n.pc,n.r),[a,h]=e.point2line(l.center,o);if(t.Utils.GE(a,l.r)&&h.end.on(i)){let[t,i]=e.point2circle(h.end,l);if(i.end.on(n))return[t,i]}let c,f,p=[];return p.push(e.point2arc(i.start,n)),p.push(e.point2arc(i.end,n)),[c,f]=e.point2segment(n.start,i),p.push([c,f.reverse()]),[c,f]=e.point2segment(n.end,i),p.push([c,f.reverse()]),e.sort(p),p[0]}static circle2circle(t,i){let n=t.intersect(i);if(n.length>0)return[0,new r(n[0],n[0])];if(t.center.equalTo(i.center)){let n=t.toArc(),r=i.toArc();return e.point2point(n.start,r.start)}{let n=new l(t.center,i.center),r=n.intersect(t),s=n.intersect(i),o=[];return o.push(e.point2point(r[0],s[0])),o.push(e.point2point(r[0],s[1])),o.push(e.point2point(r[1],s[0])),o.push(e.point2point(r[1],s[1])),e.sort(o),o[0]}}static circle2line(t,i){let n=t.intersect(i);if(n.length>0)return[0,new r(n[0],n[0])];let[s,o]=e.point2line(t.center,i),[l,a]=e.point2circle(o.end,t);return[l,a=a.reverse()]}static arc2line(i,n){let s=n.intersect(i);if(s.length>0)return[0,new r(s[0],s[0])];let o=new t.Circle(i.center,i.r),[l,a]=e.point2line(o.center,n);if(!t.Utils.GE(l,o.r)){let t=[];return t.push(e.point2line(i.start,n)),t.push(e.point2line(i.end,n)),e.sort(t),t[0]}{let[t,n]=e.point2circle(a.end,o);if(n.end.on(i))return[t,n]}}static arc2circle(i,n){let s=i.intersect(n);if(s.length>0)return[0,new r(s[0],s[0])];let o=new t.Circle(i.center,i.r),[l,a]=e.circle2circle(o,n);if(a.start.on(i))return[l,a];{let t=[];return t.push(e.point2circle(i.start,n)),t.push(e.point2circle(i.end,n)),e.sort(t),t[0]}}static arc2arc(i,n){let s=i.intersect(n);if(s.length>0)return[0,new r(s[0],s[0])];let o=new t.Circle(i.center,i.r),l=new t.Circle(n.center,n.r),[a,h]=e.circle2circle(o,l);if(h.start.on(i)&&h.end.on(n))return[a,h];{let t,r,s=[];return[t,r]=e.point2arc(i.start,n),r.end.on(n)&&s.push([t,r]),[t,r]=e.point2arc(i.end,n),r.end.on(n)&&s.push([t,r]),[t,r]=e.point2arc(n.start,i),r.end.on(i)&&s.push([t,r.reverse()]),[t,r]=e.point2arc(n.end,i),r.end.on(i)&&s.push([t,r.reverse()]),[t,r]=e.point2point(i.start,n.start),s.push([t,r]),[t,r]=e.point2point(i.start,n.end),s.push([t,r]),[t,r]=e.point2point(i.end,n.start),s.push([t,r]),[t,r]=e.point2point(i.end,n.end),s.push([t,r]),e.sort(s),s[0]}}static point2polygon(i,n){let s=[Number.POSITIVE_INFINITY,new r];for(let o of n.edges){let[n,l]=o.shape instanceof r?e.point2segment(i,o.shape):e.point2arc(i,o.shape);t.Utils.LT(n,s[0])&&(s=[n,l])}return s}static shape2polygon(e,i){let n=[Number.POSITIVE_INFINITY,new r];for(let r of i.edges){let[i,s]=e.distanceTo(r.shape);t.Utils.LT(i,n[0])&&(n=[i,s])}return n}static polygon2polygon(e,i){let n=[Number.POSITIVE_INFINITY,new t.Segment];for(let r of e.edges)for(let e of i.edges){let[i,s]=r.shape.distanceTo(e.shape);t.Utils.LT(i,n[0])&&(n=[i,s])}return n}static box2box_minmax(t,e){let i=Math.max(Math.max(t.xmin-e.xmax,0),Math.max(e.xmin-t.xmax,0)),n=Math.max(Math.max(t.ymin-e.ymax,0),Math.max(e.ymin-t.ymax,0)),r=i*i+n*n,s=t.merge(e),o=s.xmax-s.xmin,l=s.ymax-s.ymin;return[r,o*o+l*l]}static minmax_tree_process_level(i,n,r,s){let o,l;for(let a of n)[o,l]=e.box2box_minmax(i.box,a.item.key),a.item.value instanceof t.Edge?s.insert([o,l],a.item.value.shape):s.insert([o,l],a.item.value),t.Utils.LT(l,r)&&(r=l);if(0===n.length)return r;let a=n.map(t=>t.left.isNil()?void 0:t.left).filter(t=>void 0!==t),h=n.map(t=>t.right.isNil()?void 0:t.right).filter(t=>void 0!==t),c=[...a,...h].filter(n=>{let[s,o]=e.box2box_minmax(i.box,n.max);return t.Utils.LE(s,r)});return r=e.minmax_tree_process_level(i,c,r,s)}static minmax_tree(t,i,r){let s=new n,o=[i.index.root],l=r<Number.POSITIVE_INFINITY?r*r:Number.POSITIVE_INFINITY;return l=e.minmax_tree_process_level(t,o,l,s),s}static minmax_tree_calc_distance(i,n,r){let s,o;if(null!=n&&!n.isNil()){if([s,o]=e.minmax_tree_calc_distance(i,n.left,r),o)return[s,o];if(t.Utils.LT(s[0],Math.sqrt(n.item.key.low)))return[s,!0];let[l,a]=e.distance(i,n.item.value);return t.Utils.LT(l,s[0])&&(s=[l,a]),[s,o]=e.minmax_tree_calc_distance(i,n.right,s),[s,o]}return[r,!1]}static shape2planarSet(i,n,r=Number.POSITIVE_INFINITY){let s=[r,new t.Segment],o=!1;if(n instanceof t.PlanarSet){let t=e.minmax_tree(i,n,r);[s,o]=e.minmax_tree_calc_distance(i,t.root,s)}return s}static sort(e){e.sort((e,i)=>t.Utils.LT(e[0],i[0])?-1:t.Utils.GT(e[0],i[0])?1:0)}static distance(t,e){return t.distanceTo(e)}}}},function(t,e,i){"use strict";t.exports=function(t){let{Edge:e,Face:i,PlanarSet:n,Box:r}=t,{ray_shoot:s}=t;t.Polygon=class e{constructor(){this.faces=new n,this.edges=new n}get box(){return[...this.faces].reduce((t,e)=>t.merge(e.box),new r)}get vertices(){return[...this.edges].map(t=>t.start)}addFace(...t){let e=new i(this,...t);return this.faces.add(e),e}deleteFace(t){for(let e of t){this.edges.delete(e)}return this.faces.delete(t)}removeChain(t,e,i){if(i.next!==e){for(let n=e;n!==i.next;n=n.next)if(t.remove(this.edges,n),t.isEmpty()){this.deleteFace(t);break}}else this.deleteFace(t)}addVertex(e,i){let n=i.shape.split(e);if(n.length<2)return;let r=new t.Edge(n[0]),s=i.prev;return i.face.insert(this.edges,r,s),this.edges.delete(i),i.shape=n[1],this.edges.add(i),r}reverse(){for(let t of this.faces)t.reverse();return this}clone(){let t=new e;for(let e of this.faces){let i=[];for(let t of e)i.push(t.shape.clone());t.addFace(i)}return t}area(){let t=[...this.faces].reduce((t,e)=>t+e.signedArea(),0);return Math.abs(t)}contains(e){let i=s(this,e);return i==t.INSIDE||i==t.BOUNDARY}distanceTo(e){let{Distance:i}=t;if(e instanceof t.Point){let[t,n]=i.point2polygon(e,this);return[t,n=n.reverse()]}if(e instanceof t.Circle||e instanceof t.Line||e instanceof t.Segment||e instanceof t.Arc){let[t,n]=i.shape2polygon(e,this);return[t,n=n.reverse()]}if(e instanceof t.Polygon){let n,r,s=[Number.POSITIVE_INFINITY,new t.Segment];for(let o of this.edges){let l=s[0];[n,r]=i.shape2planarSet(o.shape,e.edges,l),t.Utils.LT(n,l)&&(s=[n,r])}return s}}svg(t={stroke:"black",strokeWidth:"3",fill:"lightcyan",fillRule:"evenodd"}){let{stroke:e,strokeWidth:i,fill:n,fillRule:r}=t,s=`\n<path stroke="${e}" stroke-width="${i}" fill="${n}" fill-rule="${r}" d="`;for(let t of this.faces)s+=t.svg();return s+='">\n</path>'}toJSON(){return[...this.faces].map(t=>t.toJSON())}}}},function(t,e,i){"use strict";t.exports=function(t){let{Polygon:e,Point:i,Segment:n,Arc:r,Line:s,Ray:o}=t;t.ray_shoot=function(e,i){let r=void 0;if(e.box.notIntersect(i.box))return t.OUTSIDE;let l=new o(i),a=new s(l.pt,l.norm),h=e.edges.search(l.box);if(0==h.length)return t.OUTSIDE;let c=[];for(let e of h)for(let n of l.intersect(e.shape)){if(n.equalTo(i))return t.BOUNDARY;c.push({pt:n,edge:e})}c.sort((e,i)=>t.Utils.LT(e.pt.x,i.pt.x)?-1:t.Utils.GT(e.pt.x,i.pt.x)?1:0);let f=0;for(let e=0;e<c.length;e++){let i=c[e];if(i.pt.equalTo(i.edge.shape.start)){if(e>0&&i.pt.equalTo(c[e-1].pt)&&i.edge.prev===c[e-1].edge)continue;let t=i.edge.prev.shape.tangentInEnd(),n=i.pt.translate(t),r=i.edge.shape.tangentInStart(),s=i.pt.translate(r),o=n.leftTo(a),l=s.leftTo(a);(o&&!l||!o&&l)&&f++}else if(i.pt.equalTo(i.edge.shape.end)){if(e>0&&i.pt.equalTo(c[e-1].pt)&&i.edge.next===c[e-1].edge)continue;let t=i.edge.next.shape.tangentInStart(),n=i.pt.translate(t),r=i.edge.shape.tangentInEnd(),s=i.pt.translate(r),o=n.leftTo(a),l=s.leftTo(a);(o&&!l||!o&&l)&&f++}else if(i.edge.shape instanceof n)f++;else{let e=i.edge.shape.box;t.Utils.EQ(i.pt.y,e.ymin)||t.Utils.EQ(i.pt.y,e.ymax)||f++}}return r=f%2==1?t.INSIDE:t.OUTSIDE}}},function(t,e,i){"use strict";t.exports=function(t){let{Point:e,Segment:i,Line:n,Circle:r,Arc:s,Box:o,Vector:l}=t;t.Ray=class r{constructor(...i){if(this.pt=new e,0!=i.length)if(1==i.length&&i[0]instanceof e)this.pt=i[0].clone();else{if(2!=i.length||"number"!=typeof i[0]||"number"!=typeof i[1])throw t.Errors.ILLEGAL_PARAMETERS;this.pt=new e(i[0],i[1])}}clone(){return new r(this.pt)}get box(){return new o(this.pt.x,this.pt.y,Number.POSITIVE_INFINITY,this.pt.y)}get start(){return this.pt}get norm(){return new l(0,1)}intersect(t){return t instanceof i?this.intersectRay2Segment(this,t):t instanceof s?this.intersectRay2Arc(this,t):void 0}intersectRay2Segment(e,i){let r=[];if(e.box.notIntersect(i.box))return r;let s=new n(e.start,e.norm),o=s.intersect(i);for(let i of o)t.Utils.GE(i.x,e.start.x)&&r.push(i);return 2==o.length&&1==r.length&&e.start.on(s)&&r.push(e.start),r}intersectRay2Arc(e,i){let r=[];if(e.box.notIntersect(i.box))return r;let s=new n(e.start,e.norm).intersect(i);for(let i of s)t.Utils.GE(i.x,e.start.x)&&r.push(i);return r}},t.ray=((...e)=>new t.Ray(...e))}},function(t,e,i){"use strict";t.exports=function(t){let{Point:e,Segment:i,Arc:n,Box:r,Edge:s}=t;t.Face=class r{constructor(t,...o){if(this.first,this.last,this._box=void 0,this._orientation=void 0,0!=o.length){if(1==o.length)if(o[0]instanceof Array){let s=o[0];if(0==s.length)return;if(s.every(t=>t instanceof e)){let e=r.points2segments(s);this.shapes2face(t.edges,e)}else if(s.every(t=>t instanceof i||t instanceof n))this.shapes2face(t.edges,s);else if(s.every(t=>"segment"===t.name||"arc"===t.name)){let r=[];for(let t of s){let s;s="segment"===t.name?new i(t.ps.x,t.ps.y,t.pe.x,t.pe.y):new n(new e(t.pc.x,t.pc.y),t.r,t.startAngle,t.endAngle,t.counterClockwise),r.push(s)}this.shapes2face(t.edges,r)}}else if(o[0]instanceof r){let e=o[0];this.first=e.first,this.last=e.last;for(let i of e)t.edges.add(i)}2==o.length&&o[0]instanceof s&&o[1]instanceof s&&(this.first=o[0],this.last=o[1],this.last.next=this.first,this.first.prev=this.last,this.setArcLength())}}[Symbol.iterator](){let t=void 0;return{next:()=>{let e=t||this.first,i=!this.first||!!t&&t===this.first;return t=e?e.next:void 0,{value:e,done:i}}}}get edges(){let t=[];for(let e of this)t.push(e);return t}get size(){let t=0;for(let e of this)t++;return t}static points2segments(t){let e=[];for(let n=0;n<t.length;n++)e.push(new i(t[n],t[(n+1)%t.length]));return e}shapes2face(t,e){for(let i of e){let e=new s(i);this.append(t,e)}}isEmpty(){return void 0===this.first&&void 0===this.last}append(t,e){void 0===this.first?(e.prev=e,e.next=e,this.first=e,this.last=e,e.arc_length=0):(e.prev=this.last,this.last.next=e,this.last=e,this.last.next=this.first,this.first.prev=this.last,e.arc_length=e.prev.arc_length+e.prev.length),e.face=this,t.add(e)}insert(t,e,i){if(void 0===this.first)edge.prev=e,edge.next=e,this.first=e,this.last=e;else{let t=i.next;i.next=e,t.prev=e,e.prev=i,e.next=t,this.last===i&&(this.first=e)}e.face=this,t.add(e)}remove(t,e){e===this.first&&e===this.last?(this.first=void 0,this.last=void 0):(e.prev.next=e.next,e.next.prev=e.prev,e===this.first&&(this.first=e.next),e===this.last&&(this.last=e.prev)),t.delete(e)}reverse(){let t=[],e=this.last;do{e.shape=e.shape.reverse(),t.push(e),e=e.prev}while(e!==this.last);this.first=void 0,this.last=void 0;for(let e of t)void 0===this.first?(e.prev=e,e.next=e,this.first=e,this.last=e,e.arc_length=0):(e.prev=this.last,this.last.next=e,this.last=e,this.last.next=this.first,this.first.prev=this.last,e.arc_length=e.prev.arc_length+e.prev.length);void 0!==this._orientation&&(this._orientation=void 0,this._orientation=this.orientation())}setArcLength(){for(let t of this)t===this.first?t.arc_length=0:t.arc_length=t.prev.arc_length+t.prev.length,t.face=this}area(){return Math.abs(this.signedArea())}signedArea(){let t=0;for(let e of this)t+=e.shape.definiteIntegral(this.box.ymin);return t}orientation(){if(void 0===this._orientation){let e=this.signedArea();t.Utils.EQ_0(e)?this._orientation=t.ORIENTATION.NOT_ORIENTABLE:t.Utils.LT(e,0)?this._orientation=t.ORIENTATION.CCW:this._orientation=t.ORIENTATION.CW}return this._orientation}get box(){if(void 0===this._box){let e=new t.Box;for(let t of this)e=e.merge(t.box);this._box=e}return this._box}getRelation(e){this.first.bv=this.first.bvStart=this.first.bvEnd=void 0;let i=this.first.setInclusion(e),n=e.faces.search(this.box);if(0===n.length)return i;{let r=new t.Polygon;r.addFace(this);let s=0;for(let e of n){e.first.bv=e.first.bvStart=e.first.bvEnd=void 0,e.first.setInclusion(r)===t.INSIDE&&s++}if(i===t.OUTSIDE)return 0===s?t.OUTSIDE:s===n.length&&n.length===e.faces.size?t.CONTAINS:t.INTERLACE;if(i===t.INSIDE)return 0===s?t.INSIDE:t.INTERLACE}}toJSON(){return this.edges.map(t=>t.toJSON())}svg(){let t=`\nM${this.first.start.x},${this.first.start.y}`;for(let e of this)t+=e.svg();return t+=" z"}}}},function(t,e){t.exports=function(t){t.Edge=class{constructor(t){this.shape=t,this.next,this.prev,this.face,this.arc_length=0,this.bvStart=void 0,this.bvEnd=void 0,this.bv=void 0,this.overlap=void 0}get start(){return this.shape.start}get end(){return this.shape.end}get length(){return this.shape.length}get box(){return this.shape.box}middle(){return this.shape.middle()}contains(t){return this.shape.contains(t)}setInclusion(e){if(void 0!==this.bv)return this.bv;if(void 0===this.bvStart&&(this.bvStart=t.ray_shoot(e,this.start)),void 0===this.bvEnd&&(this.bvEnd=t.ray_shoot(e,this.end)),this.bvStart===t.OUTSIDE||this.bvEnd==t.OUTSIDE)this.bv=t.OUTSIDE;else if(this.bvStart===t.INSIDE||this.bvEnd==t.INSIDE)this.bv=t.INSIDE;else{let i=t.ray_shoot(e,this.middle());this.bv=i}return this.bv}setOverlap(e){let i=void 0,n=this.shape,r=e.shape;n instanceof t.Segment&&r instanceof t.Segment?n.start.equalTo(r.start)&&n.end.equalTo(r.end)?i=t.OVERLAP_SAME:n.start.equalTo(r.end)&&n.end.equalTo(r.start)&&(i=t.OVERLAP_OPPOSITE):n instanceof t.Arc&&r instanceof t.Arc?n.start.equalTo(r.start)&&n.end.equalTo(r.end)&&n.counterClockwise===r.counterClockwise&&n.middle().equalTo(r.middle())?i=t.OVERLAP_SAME:n.start.equalTo(r.end)&&n.end.equalTo(r.start)&&n.counterClockwise!==r.counterClockwise&&n.middle().equalTo(r.middle())&&(i=t.OVERLAP_OPPOSITE):(n instanceof t.Segment&&r instanceof t.Arc||n instanceof t.Arc&&r instanceof t.Segment)&&(n.start.equalTo(r.start)&&n.end.equalTo(r.end)&&n.middle().equalTo(r.middle())?i=t.OVERLAP_SAME:n.start.equalTo(r.end)&&n.end.equalTo(r.start)&&n.middle().equalTo(r.middle())&&(i=t.OVERLAP_OPPOSITE)),void 0===this.overlap&&(this.overlap=i),void 0===e.overlap&&(e.overlap=i)}svg(){if(this.shape instanceof t.Segment)return` L${this.shape.end.x},${this.shape.end.y}`;if(this.shape instanceof t.Arc){let e,i=this.shape,n=i.counterClockwise?"1":"0";if(t.Utils.EQ(i.sweep,2*Math.PI)){let r=i.counterClockwise?1:-1,s=new t.Arc(i.pc,i.r,i.startAngle,i.startAngle+r*Math.PI,i.counterClockwise),o=new t.Arc(i.pc,i.r,i.startAngle+r*Math.PI,i.endAngle,i.counterClockwise);return e="0",` A${s.r},${s.r} 0 ${e},${n} ${s.end.x},${s.end.y}\n                    A${o.r},${o.r} 0 ${e},${n} ${o.end.x},${o.end.y}`}return e=i.sweep<=Math.PI?"0":"1",` A${i.r},${i.r} 0 ${e},${n} ${i.end.x},${i.end.y}`}}toJSON(){let e=this.shape.clone();return e.name=this.shape instanceof t.Segment?"segment":"arc",e}}}},function(t,e,i){"use strict";t.exports=function(t){t.Box=class e{constructor(t,e,i,n){this.xmin=t,this.ymin=e,this.xmax=i,this.ymax=n}clone(){return new e(this.xmin,this.ymin,this.xmax,this.ymax)}get low(){return new t.Point(this.xmin,this.ymin)}get high(){return new t.Point(this.xmax,this.ymax)}get max(){return this.clone()}notIntersect(t){return this.xmax<t.xmin||this.xmin>t.xmax||this.ymax<t.ymin||this.ymin>t.ymax}intersect(t){return!this.notIntersect(t)}merge(t){return new e(void 0===this.xmin?t.xmin:Math.min(this.xmin,t.xmin),void 0===this.ymin?t.ymin:Math.min(this.ymin,t.ymin),void 0===this.xmax?t.xmax:Math.max(this.xmax,t.xmax),void 0===this.ymax?t.ymax:Math.max(this.ymax,t.ymax))}less_than(t){return!!this.low.lessThan(t.low)||!(!this.low.equalTo(t.low)||!this.high.lessThan(t.high))}equal_to(t){return this.low.equalTo(t.low)&&this.high.equalTo(t.high)}output(){return this.clone()}maximal_val(t,e){return t.merge(e)}val_less_than(t,e){return t.lessThan(e)}set(t,e,i,n){this.xmin=t,this.ymin=e,this.xmax=i,this.ymax=n}}}},function(t,e,i){"use strict";t.exports=function(t){t.Arc=class e{constructor(e=new t.Point,i=1,n=0,r=2*Math.PI,s=!0){this.pc=e.clone(),this.r=i,this.startAngle=n,this.endAngle=r,this.counterClockwise=s}clone(){return new t.Arc(this.pc.clone(),this.r,this.startAngle,this.endAngle,this.counterClockwise)}get sweep(){if(t.Utils.EQ(this.startAngle,this.endAngle))return 0;if(t.Utils.EQ(Math.abs(this.startAngle-this.endAngle),t.PIx2))return t.PIx2;let e;return e=this.counterClockwise?t.Utils.GT(this.endAngle,this.startAngle)?this.endAngle-this.startAngle:this.endAngle-this.startAngle+t.PIx2:t.Utils.GT(this.startAngle,this.endAngle)?this.startAngle-this.endAngle:this.startAngle-this.endAngle+t.PIx2,t.Utils.GT(e,t.PIx2)&&(e-=t.PIx2),t.Utils.LT(e,0)&&(e+=t.PIx2),e}get start(){return new t.Point(this.pc.x+this.r,this.pc.y).rotate(this.startAngle,this.pc)}get end(){return new t.Point(this.pc.x+this.r,this.pc.y).rotate(this.endAngle,this.pc)}get center(){return this.pc.clone()}get vertices(){return[this.start.clone(),this.end.clone()]}get length(){return Math.abs(this.sweep*this.r)}get box(){let e=this.breakToFunctional().reduce((t,e)=>t.merge(e.start.box),new t.Box);return e=e.merge(this.end.box)}contains(e){if(!t.Utils.EQ(this.pc.distanceTo(e)[0],this.r))return!1;if(e.equalTo(this.start))return!0;let i=new t.Vector(this.pc,e).slope,n=new t.Arc(this.pc,this.r,this.startAngle,i,this.counterClockwise);return t.Utils.LE(n.length,this.length)}split(e){if(!this.contains(e))return[];if(t.Utils.EQ_0(this.sweep))return[this.clone()];if(this.start.equalTo(e)||this.end.equalTo(e))return[this.clone()];let i=new t.Vector(this.pc,e).slope;return[new t.Arc(this.pc,this.r,this.startAngle,i,this.counterClockwise),new t.Arc(this.pc,this.r,i,this.endAngle,this.counterClockwise)]}middle(){let e=this.counterClockwise===t.CCW?this.startAngle+this.sweep/2:this.startAngle-this.sweep/2;return new t.Arc(this.pc,this.r,this.startAngle,e,this.counterClockwise).end}chordHeight(){return(1-Math.cos(Math.abs(this.sweep/2)))*this.r}intersect(i){return i instanceof t.Line?i.intersect(this):i instanceof t.Circle?e.intersectArc2Circle(this,i):i instanceof t.Segment?i.intersect(this):i instanceof t.Arc?e.intersectArc2Arc(this,i):void 0}distanceTo(e){let{Distance:i}=t;if(e instanceof t.Point){let[t,n]=i.point2arc(e,this);return[t,n=n.reverse()]}if(e instanceof t.Circle){let[t,n]=i.arc2circle(this,e);return[t,n]}if(e instanceof t.Line){let[t,n]=i.arc2line(this,e);return[t,n]}if(e instanceof t.Segment){let[t,n]=i.segment2arc(e,this);return[t,n=n.reverse()]}if(e instanceof t.Arc){let[t,n]=i.arc2arc(this,e);return[t,n]}if(e instanceof t.Polygon){let[t,n]=i.shape2polygon(this,e);return[t,n]}if(e instanceof t.PlanarSet){let[t,n]=i.shape2planarSet(this,e);return[t,n]}}breakToFunctional(){let e=[],i=[0,Math.PI/2,2*Math.PI/2,3*Math.PI/2],n=[this.pc.translate(this.r,0),this.pc.translate(0,this.r),this.pc.translate(-this.r,0),this.pc.translate(0,-this.r)],r=[];for(let e=0;e<4;e++)n[e].on(this)&&r.push(new t.Arc(this.pc,this.r,this.startAngle,i[e],this.counterClockwise));if(0==r.length)e.push(this.clone());else{r.sort((t,e)=>t.length-e.length);for(let i=0;i<r.length;i++){let n,s=e.length>0?e[e.length-1]:void 0;n=s?new t.Arc(this.pc,this.r,s.endAngle,r[i].endAngle,this.counterClockwise):new t.Arc(this.pc,this.r,this.startAngle,r[i].endAngle,this.counterClockwise),t.Utils.EQ_0(n.length)||e.push(n.clone())}let i,n=e.length>0?e[e.length-1]:void 0;i=n?new t.Arc(this.pc,this.r,n.endAngle,this.endAngle,this.counterClockwise):new t.Arc(this.pc,this.r,this.startAngle,this.endAngle,this.counterClockwise),t.Utils.EQ_0(i.length)||e.push(i.clone())}return e}tangentInStart(){let e=new t.Vector(this.pc,this.start),i=this.counterClockwise?Math.PI/2:-Math.PI/2;return e.rotate(i).normalize()}tangentInEnd(){let e=new t.Vector(this.pc,this.end),i=this.counterClockwise?-Math.PI/2:Math.PI/2;return e.rotate(i).normalize()}reverse(){return new e(this.pc,this.r,this.endAngle,this.startAngle,!this.counterClockwise)}static intersectArc2Arc(e,i){var n=[];if(e.box.notIntersect(i.box))return n;if(e.pc.equalTo(i.pc)&&t.Utils.EQ(e.r,i.r)){let t;return(t=e.start).on(i)&&n.push(t),(t=e.end).on(i)&&n.push(t),(t=i.start).on(e)&&n.push(t),(t=i.end).on(e)&&n.push(t),n}let r=new t.Circle(e.pc,e.r),s=new t.Circle(i.pc,i.r),o=r.intersect(s);for(let t of o)t.on(e)&&t.on(i)&&n.push(t);return n}static intersectArc2Circle(e,i){let n=[];if(e.box.notIntersect(i.box))return n;if(i.pc.equalTo(e.pc)&&t.Utils.EQ(i.r,e.r))return n.push(e.start),n.push(e.end),n;let r=i,s=new t.Circle(e.pc,e.r),o=r.intersect(s);for(let t of o)t.on(e)&&n.push(t);return n}definiteIntegral(t=0){return this.breakToFunctional().reduce((e,i)=>e+i.circularSegmentDefiniteIntegral(t),0)}circularSegmentDefiniteIntegral(e){let i=new t.Line(this.start,this.end),n=this.pc.leftTo(i),r=new t.Segment(this.start,this.end).definiteIntegral(e),s=this.circularSegmentArea();return n?r-s:r+s}circularSegmentArea(){return.5*this.r*this.r*(this.sweep-Math.sin(this.sweep))}svg(e={stroke:"black",strokeWidth:"3",fill:"none"}){let i=this.sweep<=Math.PI?"0":"1",n=this.counterClockwise?"1":"0",{stroke:r,strokeWidth:s,fill:o}=e;if(t.Utils.EQ(this.sweep,2*Math.PI)){return new t.Circle(this.pc,this.r).svg(e)}return`\n<path d="M${this.start.x},${this.start.y}\n                             A${this.r},${this.r} 0 ${i},${n} ${this.end.x},${this.end.y}"\n                    stroke="${r}" stroke-width="${s}" fill="${o}"/>`}},t.arc=((...e)=>new t.Arc(...e))}},function(t,e,i){"use strict";t.exports=function(t){t.Segment=class e{constructor(...e){if(this.ps=new t.Point,this.pe=new t.Point,0!=e.length){if(1==e.length&&e[0]instanceof Array&&4==e[0].length){let i=e[0];return this.ps=new t.Point(i[0],i[1]),void(this.pe=new t.Point(i[2],i[3]))}if(2==e.length&&e[0]instanceof t.Point&&e[1]instanceof t.Point)return this.ps=e[0].clone(),void(this.pe=e[1].clone());if(4==e.length)return this.ps=new t.Point(e[0],e[1]),void(this.pe=new t.Point(e[2],e[3]));throw t.Errors.ILLEGAL_PARAMETERS}}clone(){return new t.Segment(this.start,this.end)}get start(){return this.ps}get end(){return this.pe}get vertices(){return[this.ps.clone(),this.pe.clone()]}get length(){return this.start.distanceTo(this.end)[0]}get slope(){return new t.Vector(this.start,this.end).slope}get box(){return new t.Box(Math.min(this.start.x,this.end.x),Math.min(this.start.y,this.end.y),Math.max(this.start.x,this.end.x),Math.max(this.start.y,this.end.y))}contains(e){return t.Utils.EQ_0(this.distanceToPoint(e))}intersect(i){return i instanceof t.Line?e.intersectSegment2Line(this,i):i instanceof t.Segment?e.intersectSegment2Segment(this,i):i instanceof t.Circle?e.intersectSegment2Circle(this,i):i instanceof t.Arc?e.intersectSegment2Arc(this,i):void 0}distanceTo(e){let{Distance:i}=t;if(e instanceof t.Point){let[t,n]=i.point2segment(e,this);return[t,n=n.reverse()]}if(e instanceof t.Circle){let[t,n]=i.segment2circle(this,e);return[t,n]}if(e instanceof t.Line){let[t,n]=i.segment2line(this,e);return[t,n]}if(e instanceof t.Segment){let[t,n]=i.segment2segment(this,e);return[t,n]}if(e instanceof t.Arc){let[t,n]=i.segment2arc(this,e);return[t,n]}if(e instanceof t.Polygon){let[t,n]=i.shape2polygon(this,e);return[t,n]}if(e instanceof t.PlanarSet){let[t,n]=i.shape2planarSet(this,e);return[t,n]}}tangentInStart(){return new t.Vector(this.start,this.end).normalize()}tangentInEnd(){return new t.Vector(this.end,this.start).normalize()}reverse(){return new e(this.end,this.start)}split(e){return this.contains(e)?this.start.equalTo(this.end)?[this.clone()]:this.start.equalTo(e)||this.end.equalTo(e)?[this]:[new t.Segment(this.start,e),new t.Segment(e,this.end)]:[]}middle(){return new t.Point((this.start.x+this.end.x)/2,(this.start.y+this.end.y)/2)}distanceToPoint(e){let[i,...n]=t.Distance.point2segment(e,this);return i}definiteIntegral(t=0){return(this.end.x-this.start.x)*(this.start.y-t+(this.end.y-t))/2}static intersectSegment2Line(e,i){let n=[],r=t.Utils.EQ_0(e.length);return e.ps.on(i)&&n.push(e.ps),e.pe.on(i)&&!r&&n.push(e.pe),n.length>0?n:e.ps.leftTo(i)&&e.pe.leftTo(i)||!e.ps.leftTo(i)&&!e.pe.leftTo(i)?n:new t.Line(e.ps,e.pe).intersect(i)}static intersectSegment2Segment(e,i){let n=[];if(e.box.notIntersect(i.box))return n;let r=new t.Line(e.ps,e.pe),s=new t.Line(i.ps,i.pe);if(r.incidentTo(s))e.ps.on(i)&&n.push(e.ps),e.pe.on(i)&&n.push(e.pe),!i.ps.on(e)||i.ps.equalTo(e.ps)||i.ps.equalTo(e.pe)||n.push(i.ps),!i.pe.on(e)||i.pe.equalTo(e.ps)||i.pe.equalTo(e.pe)||n.push(i.pe);else{let t=r.intersect(s);t.length>0&&t[0].on(e)&&t[0].on(i)&&n.push(t[0])}return n}static intersectSegment2Circle(e,i){let n=[];if(e.box.notIntersect(i.box))return n;let r=new t.Line(e.ps,e.pe).intersect(i);for(let t of r)t.on(e)&&n.push(t);return n}static intersectSegment2Arc(e,i){let n=[];if(e.box.notIntersect(i.box))return n;let r=new t.Line(e.ps,e.pe),s=new t.Circle(i.pc,i.r),o=r.intersect(s);for(let t of o)t.on(e)&&t.on(i)&&n.push(t);return n}svg(t={stroke:"black",strokeWidth:"3"}){let{stroke:e,strokeWidth:i}=t;return`\n<line x1="${this.start.x}" y1="${this.start.y}" x2="${this.end.x}" y2="${this.end.y}" stroke="${e}" stroke-width="${i}" />`}},t.segment=((...e)=>new t.Segment(...e))}},function(t,e,i){"use strict";t.exports=function(t){let{Arc:e,vector:i}=t;t.Circle=class e{constructor(t,e){this.pc=t,this.r=e}clone(){return new t.Circle(this.pc.clone(),this.r)}get center(){return this.pc}get box(){return new t.Box(this.pc.x-this.r,this.pc.y-this.r,this.pc.x+this.r,this.pc.y+this.r)}contains(e){return t.Utils.LE(e.distanceTo(this.center)[0],this.r)}toArc(e=!0){return new t.Arc(this.center,this.r,Math.PI,-Math.PI,e)}intersect(i){return i instanceof t.Line?i.intersect(this):i instanceof t.Segment?i.intersect(this):i instanceof t.Circle?e.intersectCirle2Circle(this,i):i instanceof t.Arc?i.intersect(this):void 0}distanceTo(e){let{Distance:i}=t,{point2circle:n,circle2circle:r,circle2line:s,segment2circle:o,arc2circle:l}=i;if(e instanceof t.Point){let[t,i]=n(e,this);return[t,i=i.reverse()]}if(e instanceof t.Circle){let[t,i]=r(this,e);return[t,i]}if(e instanceof t.Line){let[t,i]=s(this,e);return[t,i]}if(e instanceof t.Segment){let[t,i]=o(e,this);return[t,i=i.reverse()]}if(e instanceof t.Arc){let[t,i]=l(e,this);return[t,i=i.reverse()]}if(e instanceof t.Polygon){let[t,n]=i.shape2polygon(this,e);return[t,n]}if(e instanceof t.PlanarSet){let[t,n]=i.shape2planarSet(this,e);return[t,n]}}static intersectCirle2Circle(e,i){let n=[];if(e.box.notIntersect(i.box))return n;let r=new t.Vector(e.pc,i.pc),s=e.r,o=i.r;if(t.Utils.EQ_0(s)||t.Utils.EQ_0(o))return n;if(t.Utils.EQ_0(r.x)&&t.Utils.EQ_0(r.y)&&t.Utils.EQ(s,o))return n.push(e.pc.translate(-s,0)),n;let l,a=e.pc.distanceTo(i.pc)[0];if(t.Utils.GT(a,s+o))return n;if(t.Utils.LT(a,Math.abs(s-o)))return n;if(r.x/=a,r.y/=a,t.Utils.EQ(a,s+o)||t.Utils.EQ(a,Math.abs(s-o)))return l=e.pc.translate(s*r.x,s*r.y),n.push(l),n;let h=s*s/(2*a)-o*o/(2*a)+a/2,c=e.pc.translate(h*r.x,h*r.y),f=Math.sqrt(s*s-h*h);return l=c.translate(r.rotate90CCW().multiply(f)),n.push(l),l=c.translate(r.rotate90CW().multiply(f)),n.push(l),n}svg(t={stroke:"black",strokeWidth:"3",fill:"none"}){let{stroke:e,strokeWidth:i,fill:n}=t;return`\n<circle cx="${this.pc.x}" cy="${this.pc.y}" r="${this.r}" stroke="${e}" stroke-width="${i}" fill="${n}" />`}},t.circle=((...e)=>new t.Circle(...e))}},function(t,e,i){"use strict";t.exports=function(t){t.Line=class e{constructor(...i){if(this.pt=new t.Point,this.norm=new t.Vector(0,1),0!=i.length){if(2==i.length){let n=i[0],r=i[1];if(n instanceof t.Point&&r instanceof t.Point)return this.pt=n,void(this.norm=e.points2norm(n,r));if(n instanceof t.Point&&r instanceof t.Vector){if(t.Utils.EQ_0(r.x)&&t.Utils.EQ_0(r.y))throw t.Errors.ILLEGAL_PARAMETERS;return this.pt=n.clone(),void(this.norm=r.clone())}if(n instanceof t.Vector&&r instanceof t.Point){if(t.Utils.EQ_0(n.x)&&t.Utils.EQ_0(n.y))throw t.Errors.ILLEGAL_PARAMETERS;return this.pt=r.clone(),void(this.norm=n.clone())}}throw t.Errors.ILLEGAL_PARAMETERS}}clone(){return new t.Line(this.pt,this.norm)}get slope(){return new t.Vector(this.norm.y,-this.norm.x).slope}get standard(){return[this.norm.x,this.norm.y,this.norm.dot(this.pt)]}parallelTo(e){return t.Utils.EQ_0(this.norm.cross(e.norm))}incidentTo(t){return(this.norm.equalTo(t.norm)||this.norm.equalTo(t.norm.invert()))&&this.pt.on(t)}contains(e){if(this.pt.equalTo(e))return!0;let i=new t.Vector(this.pt,e);return t.Utils.EQ_0(this.norm.dot(i))}intersect(i){return i instanceof t.Line?e.intersectLine2Line(this,i):i instanceof t.Circle?e.intersectLine2Circle(this,i):i instanceof t.Segment?i.intersect(this):i instanceof t.Arc?e.intersectLine2Arc(this,i):void 0}distanceTo(e){let{Distance:i}=t;if(e instanceof t.Point){let[t,n]=i.point2line(e,this);return[t,n=n.reverse()]}if(e instanceof t.Circle){let[t,n]=i.circle2line(e,this);return[t,n=n.reverse()]}if(e instanceof t.Segment){let[t,n]=i.segment2line(e,this);return[t,n.reverse()]}if(e instanceof t.Arc){let[t,n]=i.arc2line(e,this);return[t,n.reverse()]}if(e instanceof t.Polygon){let[t,n]=i.shape2polygon(this,e);return[t,n]}}static points2norm(e,i){if(e.equalTo(i))throw t.Errors.ILLEGAL_PARAMETERS;return new t.Vector(e,i).normalize().rotate90CCW()}static intersectLine2Line(e,i){let n=[],[r,s,o]=e.standard,[l,a,h]=i.standard,c=r*a-s*l,f=o*a-s*h,p=r*h-o*l;if(!t.Utils.EQ_0(c)){let e=new t.Point(f/c,p/c);n.push(e)}return n}static intersectLine2Circle(e,i){let n=[],r=i.pc.projectionOn(e),s=i.pc.distanceTo(r)[0];if(t.Utils.EQ(s,i.r))n.push(r);else if(t.Utils.LT(s,i.r)){var o,l,a=Math.sqrt(i.r*i.r-s*s);o=e.norm.rotate90CCW().multiply(a),l=r.translate(o),n.push(l),o=e.norm.rotate90CW().multiply(a),l=r.translate(o),n.push(l)}return n}static intersectLine2Box(e,i){let n=[new t.Point(i.xmin,i.ymin),new t.Point(i.xmax,i.ymin),new t.Point(i.xmax,i.ymax),new t.Point(i.xmin,i.ymax)],r=[new t.Segment(n[0],n[1]),new t.Segment(n[1],n[2]),new t.Segment(n[2],n[3]),new t.Segment(n[3],n[0])],s=[];for(let t of r){let i=t.intersect(e);for(let t of i)s.push(t)}return s}static intersectLine2Arc(i,n){let r=[];if(0==e.intersectLine2Box(i,n.box).length)return r;let s=new t.Circle(n.pc,n.r),o=i.intersect(s);for(let t of o)t.on(n)&&r.push(t);return r}},t.line=((...e)=>new t.Line(...e))}},function(t,e,i){"use strict";t.exports=function(t){t.Vector=class e{constructor(...e){if(this.x=0,this.y=0,0!=e.length){if(2==e.length){let i=e[0],n=e[1];if("number"==typeof i&&"number"==typeof n)return this.x=i,void(this.y=n);if(i instanceof t.Point&&n instanceof t.Point)return this.x=n.x-i.x,void(this.y=n.y-i.y)}throw t.Errors.ILLEGAL_PARAMETERS}}clone(){return new e(this.x,this.y)}get slope(){let t=Math.atan2(this.y,this.x);return t<0&&(t=2*Math.PI+t),t}get length(){return Math.sqrt(this.dot(this))}equalTo(e){return t.Utils.EQ(this.x,e.x)&&t.Utils.EQ(this.y,e.y)}multiply(t){return new e(t*this.x,t*this.y)}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}normalize(){if(!t.Utils.EQ_0(this.length))return new e(this.x/this.length,this.y/this.length);throw t.Errors.ZERO_DIVISION}rotate(e){let i=new t.Point(this.x,this.y).rotate(e);return new t.Vector(i.x,i.y)}rotate90CCW(){return new t.Vector(-this.y,this.x)}rotate90CW(){return new t.Vector(this.y,-this.x)}invert(){return new t.Vector(-this.x,-this.y)}},t.vector=((...e)=>new t.Vector(...e))}},function(t,e){t.exports=function(t){t.Point=class e{constructor(t=0,e=0){this.x=Number.isNaN(t)?0:t,this.y=Number.isNaN(e)?0:e}get box(){return new t.Box(this.x,this.y,this.x,this.y)}clone(){return new t.Point(this.x,this.y)}get vertices(){return[this.clone()]}equalTo(e){return t.Utils.EQ(this.x,e.x)&&t.Utils.EQ(this.y,e.y)}lessThan(e){return!!t.Utils.LT(this.y,e.y)||!(!t.Utils.EQ(this.y,e.y)||!t.Utils.LT(this.x,e.x))}rotate(e,i={x:0,y:0}){var n=i.x+(this.x-i.x)*Math.cos(e)-(this.y-i.y)*Math.sin(e),r=i.y+(this.x-i.x)*Math.sin(e)+(this.y-i.y)*Math.cos(e);return new t.Point(n,r)}translate(...e){if(1==e.length&&e[0]instanceof t.Vector)return new t.Point(this.x+e[0].x,this.y+e[0].y);if(2==e.length&&"number"==typeof e[0]&&"number"==typeof e[1])return new t.Point(this.x+e[0],this.y+e[1]);throw t.Errors.ILLEGAL_PARAMETERS}projectionOn(e){if(this.equalTo(e.pt))return this.clone();let i=new t.Vector(this,e.pt);if(t.Utils.EQ_0(i.cross(e.norm)))return e.pt.clone();let n=i.dot(e.norm),r=e.norm.multiply(n);return this.translate(r)}leftTo(e){let i=new t.Vector(e.pt,this);return t.Utils.GT(i.dot(e.norm),0)}distanceTo(i){let{Distance:n}=t;if(i instanceof e){let e=i.x-this.x,n=i.y-this.y;return[Math.sqrt(e*e+n*n),new t.Segment(this,i)]}return i instanceof t.Line?n.point2line(this,i):i instanceof t.Circle?n.point2circle(this,i):i instanceof t.Segment?n.point2segment(this,i):i instanceof t.Arc?n.point2arc(this,i):i instanceof t.Polygon?n.point2polygon(this,i):i instanceof t.PlanarSet?n.shape2planarSet(this,i):void 0}on(e){return e instanceof t.Point?this.equalTo(e):e instanceof t.Line?e.contains(this):e instanceof t.Circle?e.contains(this):e instanceof t.Segment?e.contains(this):e instanceof t.Arc?e.contains(this):e instanceof t.Polygon?e.contains(this):void 0}svg(t={r:"5",stroke:"black",strokeWidth:"1",fill:"red"}){let{r:e,stroke:i,strokeWidth:n,fill:r}=t;return`\n<circle cx="${this.x}" cy="${this.y}" r="${e}" stroke="${i}" stroke-width="${n}" fill="${r}" />`}},t.point=((...e)=>new t.Point(...e))}},function(t,e){t.exports=class t{constructor(t,e){this.low=t,this.high=e}get max(){return this.high}interval(e,i){return new t(e,i)}clone(){return new t(this.low,this.high)}less_than(t){return this.low<t.low||this.low==t.low&&this.high<t.high}equal_to(t){return this.low==t.low&&this.high==t.high}intersect(t){return!this.not_intersect(t)}not_intersect(t){return this.high<t.low||t.high<this.low}output(){return[this.low,this.high]}maximal_val(t,e){return Math.max(t,e)}val_less_than(t,e){return t<e}}},function(t,e,i){"use strict";let n=i(15),{RB_TREE_COLOR_RED:r,RB_TREE_COLOR_BLACK:s}=i(0);t.exports=class{constructor(t,e,i=null,r=null,o=null,l=s){this.left=i,this.right=r,this.parent=o,this.color=l,this.item={key:t,value:e},t&&t instanceof Array&&2==t.length&&(Number.isNaN(t[0])||Number.isNaN(t[1])||(this.item.key=new n(Math.min(t[0],t[1]),Math.max(t[0],t[1])))),this.max=this.item.key?this.item.key.max:void 0}isNil(){return void 0===this.item.key&&void 0===this.item.value&&null===this.left&&null===this.right&&this.color===s}less_than(t){return this.item.key.less_than(t.item.key)}equal_to(t){let e=!0;return this.item.value&&t.item.value&&(e=this.item.value.equal_to?this.item.value.equal_to(t.item.value):this.item.value==t.item.value),this.item.key.equal_to(t.item.key)&&e}intersect(t){return this.item.key.intersect(t.item.key)}copy_data(t){this.item.key=t.item.key.clone(),this.item.value=t.item.value}update_max(){if(this.max=this.item.key?this.item.key.max:void 0,this.right&&this.right.max){let t=this.item.key.maximal_val;this.max=t(this.max,this.right.max)}if(this.left&&this.left.max){let t=this.item.key.maximal_val;this.max=t(this.max,this.left.max)}}not_intersect_left_subtree(t){return(0,this.item.key.val_less_than)(this.left.max.high?this.left.max.high:this.left.max,t.item.key.low)}not_intersect_right_subtree(t){let e=this.item.key.val_less_than,i=this.right.max.low?this.right.max.low:this.right.item.key.low;return e(t.item.key.high,i)}}},function(t,e,i){"use strict";let n=i(1);t.exports=function(t){t.PlanarSet=class extends Set{constructor(){super(),this.index=new n}add(t){let e=this.size;if(super.add(t),this.size>e){this.index.insert(t.box,t)}return this}delete(t){let e=super.delete(t);return e&&this.index.remove(t.box,t),e}clear(){}search(t){return this.index.search(t)}hit(e){let i=new t.Box(e.x-1,e.y-1,e.x+1,e.y+1);return this.index.search(i).filter(t=>e.on(t))}svg(){return[...this].reduce((t,e)=>t+e.svg(),"")}}}},function(t,e){t.exports={ILLEGAL_PARAMETERS:new ReferenceError("Illegal Parameters"),ZERO_DIVISION:new Error("Zero division")}},function(t,e){t.exports={DP_TOL:1e-6,EQ_0:function(t){return t<1e-6&&t>-1e-6},EQ:function(t,e){return t-e<1e-6&&t-e>-1e-6},GT:(t,e)=>t-e>1e-6,GE:(t,e)=>t-e>-1e-6,LT:(t,e)=>t-e<-1e-6,LE:(t,e)=>t-e<1e-6}},function(t,e,i){"use strict";let n=i(19),r=i(18),s=new class{constructor(){this.version="0.0.1",this.DP_TOL=n.DP_TOL,this.CCW=!0,this.CW=!1,this.ORIENTATION={CCW:-1,CW:1,NOT_ORIENTABLE:0},this.PIx2=2*Math.PI,this.PI_2=.5*Math.PI,this.Utils=n,this.Errors=r,this.INSIDE=1,this.OUTSIDE=0,this.BOUNDARY=2,this.CONTAINS=3,this.INTERLACE=4,this.CLIP_INSIDE=1,this.CLIP_OUTSIDE=0,this.BOOLEAN_UNION=1,this.BOOLEAN_INTERSECT=2,this.BOOLEAN_SUBTRACT=3,this.OVERLAP_SAME=1,this.OVERLAP_OPPOSITE=2}};i(17)(s),i(14)(s),i(13)(s),i(12)(s),i(11)(s),i(10)(s),i(9)(s),i(8)(s),i(7)(s),i(6)(s),i(5)(s),i(4)(s),i(3)(s),i(2)(s),t.exports=s},function(t,e,i){"use strict";let n=i(20),{Polygon:r,Segment:s,Arc:o}=n;const l=0,a=1,h=2;class c{static booleanOp(t){let e=new r;for(let[i,n]of t)e=c.booleanOpBinary(e,i,n);return e}static booleanOpBinary(t,e,i){return c.clip(t,e,i)}static unify(t,e){return c.booleanOpBinary(t,e,n.BOOLEAN_UNION)}static subtract(t,e){let i=e.clone().reverse();return c.booleanOpBinary(t,i,n.BOOLEAN_SUBTRACT)}static intersect(t,e){return c.booleanOpBinary(t,e,n.BOOLEAN_INTERSECT)}static arrange(t,e){let i=c.getIntersections(t,e);c.sortIntersections(i),c.splitByIntersections(t,i.int_points1_sorted),c.splitByIntersections(e,i.int_points2_sorted)}static clip(t,e,i){let n=t.clone(),r=e.clone(),s=c.getIntersections(n,r);return c.sortIntersections(s),c.splitByIntersections(n,s.int_points1_sorted),c.splitByIntersections(r,s.int_points2_sorted),c.filterDuplicatedIntersections(s),c.removeNotRelevantNotIntersectedFaces(n,r,i,s.int_points1),c.removeNotRelevantNotIntersectedFaces(r,n,i,s.int_points2),c.initializeInclusionFlags(s.int_points1),c.initializeInclusionFlags(s.int_points2),c.calculateInclusionFlags(s.int_points1,e),c.calculateInclusionFlags(s.int_points2,t),c.setOverlappingFlags(s),c.removeNotRelevantChains(n,i,s.int_points1_sorted,!0),c.removeNotRelevantChains(r,i,s.int_points2_sorted,!1),c.copyWrkToRes(n,r,i,s.int_points2),c.swapLinks(n,r,s),c.removeOldFaces(n,s.int_points1),c.removeOldFaces(r,s.int_points2),c.restoreFaces(n,s.int_points1,s.int_points2),c.restoreFaces(n,s.int_points2,s.int_points1),n}static getIntersections(t,e){let i={int_points1:[],int_points2:[]};for(let n of t.edges){let t=e.edges.search(n.box);for(let e of t){let t=n.shape.intersect(e.shape);for(let r of t)c.addToIntPoints(n,r,i.int_points1),c.addToIntPoints(e,r,i.int_points2)}}return i}static addToIntPoints(t,e,i){let r=i.length,s=t.shape.split(e);if(0===s.length)return;let o=0;1===s.length?t.shape.start.equalTo(e)?o=0:t.shape.end.equalTo(e)&&(o=t.shape.length):o=s[0].length;let c=l;n.Utils.EQ(o,0)&&(c|=a),n.Utils.EQ(o,t.shape.length)&&(c|=h);let f=c&h&&0===t.next.arc_length?0:t.arc_length+o;i.push({id:r,pt:e,arc_length:f,edge_before:t,edge_after:void 0,face:t.face,is_vertex:c})}static sortIntersections(t){0!==t.int_points1.length&&(t.int_points1_sorted=c.getSortedArray(t.int_points1),t.int_points2_sorted=c.getSortedArray(t.int_points2))}static getSortedArray(t){let e=new Map,i=0;for(let n of t)e.has(n.face)||(e.set(n.face,i),i++);for(let i of t)i.faceId=e.get(i.face);return t.slice().sort(c.compareFn)}static compareFn(t,e){return t.faceId<e.faceId?-1:t.faceId>e.faceId?1:n.Utils.LT(t.arc_length,e.arc_length)?-1:n.Utils.GT(t.arc_length,e.arc_length)?1:0}static splitByIntersections(t,e){let{Polygon:i,Segment:r,Arc:s}=n;if(e){for(let i of e){let e=i.edge_before;if(e.shape.start.equalTo(i.pt)&&(i.is_vertex|=a),e.shape.end.equalTo(i.pt)&&(i.is_vertex|=h),i.is_vertex&a){i.edge_before=e.prev,i.is_vertex=h;continue}if(i.is_vertex&h)continue;let n=t.addVertex(i.pt,e);i.edge_before=n}for(let t of e)t.edge_after=t.edge_before.next}}static filterDuplicatedIntersections(t){if(t.int_points1.length<2)return;let e=!1,i=t.int_points1_sorted[0],r=t.int_points2[i.id];for(let s=1;s<t.int_points1_sorted.length;s++){let o=t.int_points1_sorted[s];if(!n.Utils.EQ(o.arc_length,i.arc_length)){i=o,r=t.int_points2[i.id];continue}let l=t.int_points2[o.id];o.edge_before===i.edge_before&&o.edge_after===i.edge_after&&l.edge_before===r.edge_before&&l.edge_after===r.edge_after&&(o.id=-1,l.id=-1,e=!0)}r=t.int_points2_sorted[0],i=t.int_points1[r.id];for(let s=1;s<t.int_points2_sorted.length;s++){let o=t.int_points2_sorted[s];if(-1==o.id)continue;if(-1==r.id||!n.Utils.EQ(o.arc_length,r.arc_length)){r=o,i=t.int_points1[r.id];continue}let l=t.int_points1[o.id];l.edge_before===i.edge_before&&l.edge_after===i.edge_after&&o.edge_before===r.edge_before&&o.edge_after===r.edge_after&&(l.id=-1,o.id=-1,e=!0)}e&&(t.int_points1=t.int_points1.filter(t=>t.id>=0),t.int_points2=t.int_points2.filter(t=>t.id>=0),t.int_points1.forEach((t,e)=>t.id=e),t.int_points2.forEach((t,e)=>t.id=e),t.int_points1_sorted=[],t.int_points2_sorted=[],c.sortIntersections(t))}static removeNotRelevantNotIntersectedFaces(t,e,i,r){let s=[];for(let o of t.faces)if(!r.find(t=>t.face===o)){let t=o.getRelation(e);i===n.BOOLEAN_UNION&&t===n.INSIDE?s.push(o):i===n.BOOLEAN_INTERSECT&&t===n.OUTSIDE&&s.push(o)}for(let e=0;e<s.length;e++)t.deleteFace(s[e])}static initializeInclusionFlags(t){for(let e of t)e.edge_before.bvStart=void 0,e.edge_before.bvEnd=void 0,e.edge_before.bv=void 0,e.edge_before.overlap=void 0,e.edge_after.bvStart=void 0,e.edge_after.bvEnd=void 0,e.edge_after.bv=void 0,e.edge_after.overlap=void 0;for(let e of t)e.edge_before.bvEnd=n.BOUNDARY,e.edge_after.bvStart=n.BOUNDARY}static calculateInclusionFlags(t,e){for(let i of t)i.edge_before.setInclusion(e),i.edge_after.setInclusion(e)}static setOverlappingFlags(t){let e=void 0,i=void 0,r=void 0,s=t.int_points1.length;for(let o=0;o<s;o++){let l=t.int_points1_sorted[o];l.face!==e&&(i=o,e=l.face),r=o+1===s?i:t.int_points1_sorted[o+1].face!==e?i:t.int_points1_sorted[o+1];let a=l.edge_after,h=r.edge_before;if(a.bv!==n.BOUNDARY||h.bv!==n.BOUNDARY)continue;if(a!==h)continue;let c=t.int_points2[l.id],f=t.int_points2[r.id],p=c.edge_after,u=f.edge_before;p.bv===n.BOUNDARY&&u.bv===n.BOUNDARY&&p===u||(c=t.int_points2[r.id],f=t.int_points2[l.id],p=c.edge_after,u=f.edge_before),p.bv===n.BOUNDARY&&u.bv===n.BOUNDARY&&p===u&&a.setOverlap(p)}}static removeNotRelevantChains(t,e,i,r){if(i)for(let s=0;s<i.length;s++){let o,l=i[s];if(s<i.length-1&&i[s+1].face===l.face)o=i[s+1];else for(o of i)if(o.face===l.face)break;let a=l.edge_after,h=o.edge_before,c=l.face;(a.bv===n.INSIDE&&h.bv===n.INSIDE&&e===n.BOOLEAN_UNION||a.bv===n.OUTSIDE&&h.bv===n.OUTSIDE&&e===n.BOOLEAN_INTERSECT||(a.bv===n.OUTSIDE||h.bv===n.OUTSIDE)&&e===n.BOOLEAN_SUBTRACT&&!r||(a.bv===n.INSIDE||h.bv===n.INSIDE)&&e===n.BOOLEAN_SUBTRACT&&r||a.bv===n.BOUNDARY&&h.bv===n.BOUNDARY&&a.overlap&n.OVERLAP_SAME&&r||a.bv===n.BOUNDARY&&h.bv===n.BOUNDARY&&a.overlap&n.OVERLAP_OPPOSITE)&&(t.removeChain(c,a,h),l.edge_after=void 0,o.edge_before=void 0)}}static copyWrkToRes(t,e,i,r){for(let s of e.faces){for(let e of s)t.edges.add(e);i===n.BOOLEAN_UNION&&r&&void 0===r.find(t=>t.face===s)&&t.addFace(s.first,s.last)}}static swapLinks(t,e,i){if(0!==i.int_points1.length)for(let t=0;t<i.int_points1.length;t++){let e=i.int_points1[t],n=i.int_points2[t];if(void 0!==e.edge_before&&void 0===e.edge_after&&void 0===n.edge_before&&void 0!==n.edge_after&&(e.edge_before.next=n.edge_after,n.edge_after.prev=e.edge_before,e.edge_after=n.edge_after,n.edge_before=e.edge_before),void 0!==n.edge_before&&void 0===n.edge_after&&void 0===e.edge_before&&void 0!==e.edge_after&&(n.edge_before.next=e.edge_after,e.edge_after.prev=n.edge_before,n.edge_after=e.edge_after,e.edge_before=n.edge_before),void 0!==e.edge_before&&void 0===e.edge_after)for(let t of i.int_points1_sorted)t!==e&&void 0===t.edge_before&&void 0!==t.edge_after&&t.pt.equalTo(e.pt)&&(e.edge_before.next=t.edge_after,t.edge_after.prev=e.edge_before,e.edge_after=t.edge_after,t.edge_before=e.edge_before);if(void 0!==n.edge_before&&void 0===n.edge_after)for(let t of i.int_points2_sorted)t!==n&&void 0===t.edge_before&&void 0!==t.edge_after&&t.pt.equalTo(n.pt)&&(n.edge_before.next=t.edge_after,t.edge_after.prev=n.edge_before,n.edge_after=t.edge_after,t.edge_before=n.edge_before)}}static removeOldFaces(t,e){for(let i of e)t.faces.delete(i.face),i.face=void 0,i.edge_before&&(i.edge_before.face=void 0),i.edge_after&&(i.edge_after.face=void 0)}static restoreFaces(t,e,i){for(let n of e){if(void 0===n.edge_before||void 0===n.edge_after)continue;if(n.face)continue;if(n.edge_after.face||n.edge_before.face)continue;let r=n.edge_after,s=n.edge_before,o=t.addFace(r,s);for(let t of e)t.edge_before&&t.edge_after&&t.edge_before.face===o&&t.edge_after.face===o&&(t.face=o);for(let t of i)t.edge_before&&t.edge_after&&t.edge_before.face===o&&t.edge_after.face===o&&(t.face=o)}}}t.exports=c}])});
//# sourceMappingURL=flatten-boolean-op.umd.min.js.map